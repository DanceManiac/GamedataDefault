-- Kirgudu 
log_full = false --/ признак необходимости записи расширенного лога
-- Kirgudu
if (jit == nil) then
	profiler.setup_hook	()
end

function empty(container)
	if (type(container) == "function") then
		for i in container do
			return (false)
		end

		return (true)
	end

	assert (type(container) == "table")
	if (container[1] ~= nil) then
		return (false)
	end

	for i,j in pairs(container) do
		return (false)
	end

	return (true)
end

schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

-- Загружает схему из файла на диске и активирует в мотиваторе.
-- Здесь:
-- filename - имя файла, в котором реализована схема, без расширения
-- scheme - имя схемы
function load_scheme(filename, scheme, stype)
	schemes[scheme] = filename
	stypes[scheme] = stype
end

----------------------------------------------------------------------
dev_debug = false
mus_vol = 0
amb_vol = 0
----------------------------------------------------------------------

local scripts_to_print = {
	["stalker_generic"] = true,
	["xr_smartcover"] = true,
	["xr_logic"] = true,
	["xr_conditions"] = true,
	["xr_cover"] = true,
	["sim_combat"] = true,
	["xr_motivator"] = true,
	["xr_walker"] = true,
	["xr_camper"] = true,
	["xr_kamp"] = true,
	["restrictor_manager"] = true,
	["sim_board"] = true,
	["sim_faction"] = true,
	["post_combat_idle"] = true,
	["xr_death"] = true,
	["xr_sound"] = true,
	["utils"] = true,
	["treasure_manager"] = true,
	["object_collection"] = true,
	["minigames_manager"] = true,
	["minigame_crowkiller"] = true,
	["minigame_shooting"] = true,
	["se_actor"] = true,
	["smart_terrain"] = true,
	["bind_physic_object"] = true,
	["bind_heli"] = true,
	["bind_anomaly_zone"] = true,
	["bind_stalker"] = true,
	["state_mgr_animation"] = true,
	["se_stalker"] = true,
	["db"] = true,
	["sim_squad_generic"] = true,
	["sim_squad_scripted"] = true,
	["se_smart_cover"] = true,
	["se_monster"] = true,
	["xr_use"] = true,
	["dialog_manager"] = true,
	["xr_combat_ignore"] = true,
	["xr_remark"] = true,
	["cover_manager"] = true,
	["xr_danger"]	 = true
	--["task_manager"] = true,
	--["task_objects"] = true
}

function printf(fmt,...)
	local is_g = 0
	local result = fmt
	if debug == nil then
		log(string.format(fmt,...))
		return
	end
	local info_table = debug.getinfo(2)
	local script_name = string.gsub(info_table.short_src, "%.script", "")
	script_name = string.gsub(script_name, "gamedata\\scripts\\", "")
	if scripts_to_print[script_name] == true then return end
	script_name,is_g = string.gsub(script_name, "_g", "")
	if is_g == 0 then
		result = script_name..":("..info_table.currentline.."):"..fmt
	end
	log(string.format(result,...))
end

----------------------------------------------------------------------

if nil == time_global then
	time_global = function() return device():time_global() end
end

function wait_game(time_to_wait)
	verify_if_thread_is_running()
	if (time_to_wait == nil) then
		coroutine.yield()
	else
		local time_to_stop = game.time() + time_to_wait
		while game.time() <= time_to_stop do
			coroutine.yield()
		end
	end
end

function wait(time_to_wait)
	verify_if_thread_is_running()
	if (time_to_wait == nil) then
		coroutine.yield()
	else
		local time_to_stop = time_global() + time_to_wait
		while time_global() <= time_to_stop do
			coroutine.yield()
		end
	end
end

function action(obj,...)
	local arg = {...}
	local act = entity_action()
	local i = 1
	while true do
		if (arg[i] ~= nil) then
			act:set_action(arg[i])
		else
			break
		end
		i = i + 1
	end
	if (obj ~= nil) then
		obj:command(act,false)
	end
	return entity_action(act)
end

function action_first(obj,...)
	local arg = {...}
	local act = entity_action()
	local i = 1
	while true do
		if (arg[i] ~= nil) then
			act:set_action(arg[i])
		else
			break
		end
		i = i + 1
	end
	if (obj ~= nil) then
		obj:command(act,true)
	end
	return entity_action(act)
end

function round (value)
	local min = math.floor (value)
	local max = min + 1
	if value - min > max - value then return max end
	return min
end

function debug_get_level_object(obj_name)
	local res = level.debug_object(obj_name)
	while res == nil do
		printf("get_level_object() is waiting for object \"%s\"", obj_name)

		res = level.object(obj_name)
		wait()
	end
	return res
end

function debug_get_actor()
	local res = level.debug_actor()
	while res == nil do
		res = level.debug_actor()
		wait()
	end
	return res
end

function distance_between(obj1, obj2)
	return obj1:position():distance_to(obj2:position())
end

-- Если один объект nil, например нет актера, то считаем, что он далеко
function distance_between_safe(obj1, obj2)
	if(obj1 == nil or obj2 == nil) then return 100000 end
	return obj1:position():distance_to(obj2:position())
end

local aa = nil
-- Проверка на инфопоршны, даже если игрока не существует
function has_alife_info(info_id)
	if aa == nil then
		return false
	end
	return aa:has_info(0, info_id)
end

function reset_action (npc, script_name)
	if npc:get_script () then
		npc:script (false, script_name)
	end
	npc:script (true, script_name)
end

class "script_object"

function script_object.__init(self,name,script,...)
	self.action = action(nil,...)
	self.object_name = name
	self.script_name = script
	self.object = nil
end

function script_object:update()
	local obj = self.object
	self.object = level.object(self.object_name)
	if ((obj == nil) and (self.object ~= nil)) then
		self.object:script (true,self.script_name)
		self.object:command (self.action,false)
	end
end

-- Передача персонажу информации
function GiveInfoViaPda(obj_receiver, obj_sender, info_number)
	obj_receiver:give_info_portion_via_pda(info_number, obj_sender)
end


--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------

-- Константа, которую использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- Название скрипта, который в данный момент находится в отладке
-- (в этом скрипте будут срабатывать вызовы функции debug_log)
debug_script_name = ""

-- Выводит в лог строчку, если script_name == debug_script_name
-- Используется для отладки сценариев
function debug_log(script_name, fmt, ...)
	if debug_script_name == script_name then
		log(string.format(fmt, ...))
	end
end

-- Если в данный момент выполняется какое-то действие, прерывает его и отключает скриптовый режим
function interrupt_action(who, script_name)
	if who:get_script() then
		who:script(false, script_name)
	end
end

function random_choice(...)
	local arg = {...}
	local r = math.random(1, #arg)
	return arg[r]
end

function new_action(...)
	local arg = {...}
	local act = entity_action()
	for i = 1, #arg do
		act:set_action(arg[i])
	end
	return act;
end

obj_last_actions = {};

function perform_action(obj, action_name, action)
	if (obj ~= nil) then
		obj_last_actions[obj] = action_name
		obj:command(act, false)
	end
end

function last_action(obj)
	return obj_last_actions[obj]
end

function if_then_else(cond, if_true, if_false)
	if cond then
		return if_true
	end
	return if_false
end

function update_action (npc, script, ...)
	local arg = {...}
	if npc == nil then return end
	local act = npc:action ()
	if arg.n == 0 then return end

	if act == nil then act = entity_action () end

	for a = 1, arg.n, 1 do
		if arg[a] ~= nil then act:set_action (arg[a]) end
	end
	reset_action (npc, script)
	npc:command (act, false)

end

function set_current_time (hour, min, sec)
	local current_time_factor = level.get_time_factor ()

	printf ("Need time : %d:%d:%d", hour, min, sec)

	local current_time = game.time ()
	local c_day = math.floor (current_time / 86400000)
	local c_time = current_time - c_day * 86400000
	local n_time = (sec + min * 60 + hour * 3600) * 1000

	if c_time > n_time then c_day = c_day + 1 end
	n_time = n_time + c_day * 86400000

	level.set_time_factor (10000)
	while game.time () < n_time do wait () end

	level.set_time_factor (current_time_factor)
end

if (editor() == false) then
	class "pp_effector" (effector)

	function pp_effector:__init(effector_type,start_time,dest_power,life_time) super(effector_type,start_time)
		self.start_time = start_time
		self.stop_time = start_time + life_time
		self.max_power = dest_power
	end

	function pp_effector:process(pp)
		effector.process(self,pp)

		local curr_time = time_global()
		local d = 0.0

		if curr_time < self.start_time then
			d = 0.0
			else
			if curr_time < self.stop_time then
				d = (curr_time - self.start_time) / (self.stop_time - self.start_time)
				else
				self.info = self.max_power
				return true
			end
		end

		local dual = duality()
		local noise = noise()
		local base = color()
		local gray = color()
		local add = color()

		dual.h = self.max_power.dual.h * d
		dual.v = self.max_power.dual.v * d

		noise.grain = self.max_power.noise.grain * d
		noise.intensity = self.max_power.noise.intensity * d
		noise.fps = self.max_power.noise.fps * d

		base.r = self.max_power.color_base.r * d
		base.g = self.max_power.color_base.g * d
		base.b = self.max_power.color_base.b * d

		gray.r = self.max_power.color_gray.r * d
		gray.g = self.max_power.color_gray.g * d
		gray.b = self.max_power.color_gray.b * d

		add.r = self.max_power.color_add.r * d
		add.g = self.max_power.color_add.g * d
		add.b = self.max_power.color_add.b * d

		pp.gray = self.max_power.gray * d
		pp.blur = self.max_power.blur * d

		pp.dual = dual
		pp.noise = noise
		pp.color_base = base
		pp.color_gray = gray
		pp.color_add = add

		self.info = pp

		return true
	end

	function pp_effector:finished()
		return self.stop_time < time_global()
	end

	-- postprocess for rainbow
	class "pp_linear_lerp" (effector)

	function pp_linear_lerp:__init(effector_type,start_time,life_time,start_power,dest_power) super(effector_type,start_time)
		self.start_time = start_time
		self.stop_time = start_time + life_time
		self.min_power = start_power
		self.max_power = dest_power
	end

	function pp_linear_lerp:process(pp)
		effector.process(self,pp)

		local curr_time = time_global()
		local d = 0.0

		if curr_time < self.start_time then
			d = 0.0
			else
			if curr_time < self.stop_time then
				d = (curr_time - self.start_time) / (self.stop_time - self.start_time)
				else
				self.info = self.max_power
				return true
			end
		end

		local dual = duality()
		local noise = noise()
		local base = color()
		local gray = color()
		local add = color()

		dual.h = self.min_power.dual.h + (self.max_power.dual.h - self.min_power.dual.h ) * d
		dual.v = self.min_power.dual.v + (self.max_power.dual.v - self.min_power.dual.v ) * d

		noise.grain = self.min_power.noise.grain + (self.max_power.noise.grain - self.min_power.noise.grain ) * d
		noise.intensity = self.min_power.noise.intensity + (self.max_power.noise.intensity - self.min_power.noise.intensity) * d
		noise.fps = self.min_power.noise.fps + (self.max_power.noise.fps - self.min_power.noise.fps ) * d

		base.r = self.min_power.color_base.r + (self.max_power.color_base.r - self.min_power.color_base.r ) * d
		base.g = self.min_power.color_base.g + (self.max_power.color_base.g - self.min_power.color_base.g ) * d
		base.b = self.min_power.color_base.b + (self.max_power.color_base.b - self.min_power.color_base.b ) * d

		gray.r = self.min_power.color_gray.r + (self.max_power.color_gray.r - self.min_power.color_gray.r ) * d
		gray.g = self.min_power.color_gray.g + (self.max_power.color_gray.g - self.min_power.color_gray.g ) * d
		gray.b = self.min_power.color_gray.b + (self.max_power.color_gray.b - self.min_power.color_gray.b ) * d

		add.r = self.min_power.color_add.r + (self.max_power.color_add.r - self.min_power.color_add.r ) * d
		add.g = self.min_power.color_add.g + (self.max_power.color_add.g - self.min_power.color_add.g ) * d
		add.b = self.min_power.color_add.b + (self.max_power.color_add.b - self.min_power.color_add.b ) * d

		pp.gray = self.min_power.gray + (self.max_power.gray - self.min_power.gray ) * d
		pp.blur = self.min_power.blur + (self.max_power.blur - self.min_power.blur ) * d

		pp.dual = dual
		pp.noise = noise
		pp.color_base = base
		pp.color_gray = gray
		pp.color_add = add

		self.info = pp

		return true
	end

	function pp_linear_lerp:finished()
		return          self.stop_time < time_global()
	end
	-- end of postprocess for rainbow

	----------------------------------------------------------------------------------------------------------------------
	-- Evaluators
	----------------------------------------------------------------------------------------------------------------------
	-- Зарезервированы id с номерами от 0 до 256 для создания стандартных эвалуаторов.

	--Constant evaluator
	class "const_evaluator" (property_evaluator)

	function const_evaluator:__init (name, value) super (nil, name)
		self.value = value
	end

	function const_evaluator:evaluate()
		return self.value
	end

	--Wait evaluator
	class "wait_evaluator" (property_evaluator)

	function wait_evaluator:__init (wait_time) super ()
		self.wait_time = wait_time
		self.first_call = true
		self.current_time = 0
	end

	function wait_evaluator:evaluate ()
		if self.first_call == true then
			self.first_call = false
			self.current_time = device ():time_global ()
			return false
		end

		local t = device():time_global () - self.current_time;
		if t > self.wait_time then return true end
		return false
	end

	--------------------------------------------------------------------------------

	class "enabled_evaluator" (property_evaluator)

	function enabled_evaluator:__init (name, storage) super ()
		self.a = storage
	end

	function enabled_evaluator:evaluate()
		return self.a.enabled
	end

end -- end of editor() == false


function str_split (str)

	local strlen = string.len (str)

	local parts = {{}, {}, {}, {}}
	local cpart = 1

	for a = 1, strlen, 1 do
		local char = string.byte (str, a)
		if char ~= 95 then
			table.insert (parts[cpart], char)
			else
			cpart = cpart + 1
			if cpart > 4 then break end
		end
	end

	if cpart ~= 4 then return "unknown", "stalker", 0, 0 end

	local str1 = string.char ()
	local str2 = string.char ()
	local str3 = string.char ()
	local str4 = string.char ()

	local ref = parts[1]
	for a = 1, #ref, 1 do
		str1 = string.format ("%s%c", str1, ref[a])
	end

	ref = parts[2]
	for a = 1, #ref, 1 do
		str2 = string.format ("%s%c", str2, ref[a])
	end

	ref = parts[3]
	for a = 1, #ref, 1 do
		str3 = string.format ("%s%c", str3, ref[a])
	end

	ref = parts[4]
	for a = 1, #ref, 1 do
		str4 = string.format ("%s%c", str4, ref[a])
	end

	printf ("%s %s %d %d", str1, str2, str3, str4)
	return str1, str2, (str3 + 1) - 1, (str4 + 1) - 1
end

function random_number (min_value, max_value)
	math.randomseed (device ():time_global ())
	if min_value == nil and max_value == nil then
		return math.random ()
		else
		return math.random (min_value, max_value)
	end
end

-- Время суток в мс
-- Чугай
local ms_per_day = 24 * 60 * 60 * 1000
function day_time()
	return math.mod( game.time(), ms_per_day )
end

--Time in hours
function local_hours()
	return math.floor( math.mod( game.time()/1000, 86400 )/ 3600 )
end

-- Парсит строку вида "ааа, ббб, ввв..." в таблицу {"ааа", "ббб", "ввв", ...}
-- Чугай
function parse_names( s )
	local t = {}
	for name in string.gfind( s, "([%w_\\]+)%p*" ) do
		--for name in string.gfind( s, "%s*([^%,]+)%s*" ) do
		table.insert( t, name )
	end

	return t
end

function parse_key_value( s )
	local t = {}
	if s == nil then
		return nil
	end
	local key, nam = nil, nil
	for name in string.gfind( s, "([%w_\\]+)%p*" ) do
		if key == nil then
			key = name
		else
			t[key] = name
			key = nil
		end
	end
	return t
end

function empty (container)
	if (type(container) == "function") then
		for i in container do
			return (false)
		end
		return (true)
	end
	if (container[1] ~= nil) then
		return  (false)
	end
	for i,j in pairs(container) do
		return (false)
	end
	return (true)
end

-- Парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - целые числа
-- Чугай
--[[function parse_nums( s )
	local t = {}

	for entry in string.gfind( s, "([%w_\\]+)%p*" ) do
	table.insert( t, tonumber( entry ) )
	end

	return t
end]]

-- Парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - дробные числа
function parse_nums( s )
	local t = {}

	for entry in string.gfind( s, "([%-%d%.]+)%,*" ) do
		table.insert( t, tonumber( entry ) )
	end

	return t
end

-- Проверяет, есть ли объект в онлайне
function is_object_online(obj_id)
	return level.object_by_id(obj_id) ~= nil
end

function get_clsid(npc)
	if npc == nil then return nil end
	return npc:clsid()

	-- if is_object_online(npc:id()) then
	--	 return npc:clsid()
	-- else
	--	 return nil
	-- end
end

-- Вычисляет yaw в радианах
function yaw( v1, v2 )
	return math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) )
end

function yaw_degree( v1, v2 )
	return (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / ( math.sqrt(v1.x*v1.x + v1.z*v1.z ) * math.sqrt(v2.x*v2.x + v2.z*v2.z ) ) ) * 57.2957)
end
function yaw_degree3d( v1, v2 )
	return (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/(math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross(v1, v2)
	return vector():set(v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

-- Вращает вектор вокруг оси y против часовой стрелки

function vector_rotate_y(v, angle)
	angle = angle * 0.017453292519943295769236907684886
	local c = math.cos (angle)
	local s = math.sin (angle)
	return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

-- Очистка таблицы
function clear_table (t)
	while #t > 0 do
		table.remove (t, #t)
	end
end

-- Использует для монстров. Выбор точки, куда идти в некотором радиусе и чтоб точка была дальше на расстоянии
-- min_radius от текущей позиции (если это получится). center_id - центр позиции, вокруг которой живем,
-- position_id - тукущая позиция, radius - в каком радиусе выбирать точку, min_radius - минимальное расстояние, от текущей позиции до новой точки.
function new_point(center_id, position_id,radius, min_radius)
	local dir = vector():set(math.random(-1000, 1000)/1000.0, 0.0001, math.random(-1000, 1000)/1000.0)
	local pos = level.vertex_in_direction(center_id, dir, radius)
	local i = 1
	printf("vertex_position")
	while(level.vertex_position(position_id):distance_to(level.vertex_position(pos) ) < min_radius and i < 20) do
		dir = vector():set(math.random(-1000, 1000)/1000.0, 0.0001, math.random(-1000, 1000)/1000.0)
		pos = level.vertex_in_direction(center_id, dir, radius)
		i = i + 1
	end

	return (level.vertex_position(pos))
end

function stop_play_sound(obj)
	if obj:alive() == true then
		obj:set_sound_mask(-1)
		obj:set_sound_mask(0)
	end
end

-- Возвращает произвольную точку пути у которой установлен бит
-- old_point - индекс точки, которую не надо выбирать,
-- Параметр не обязательный (например текущей точки)
function point_with_bit(patrol_path, bit, old_point)
	local points = {}

	for i = 0, patrol_path:count()-1 do
		-- Добавляем в таблицу точки с нужным битом
		if( patrol_path:flag(i, bit)) then
			-- Добавляем точку если old_point == nil или новая точка не совпадает с old_point
			if(old_point == nil) then
				table.insert(points, patrol_path:point(i))
			elseif(old_point ~= i) then
				table.insert(points, patrol_path:point(i))
			end
		end
	end

	local number_point = #points

	if(number_point == 0) then
		return nil
	elseif(number_point == 1) then
		return points[1]
	else
		return points[math.random(1, number_point)]
	end
end

-- Возвращает произвольную точку пути у которой установлен бит
-- old_point - индекс точки, которую не надо выбирать,
-- Параметр не обязательный (например текущей точки)
function point_with_bit_id(patrol_path, bit, old_point)
	local points = {}

	for i = 0, patrol_path:count()-1 do
		-- Добавляем в таблицу точки с нужным битом
		if( patrol_path:flag(i, bit)) then
			-- Добавляем точку если old_point == nil или новая точка не совпадает с old_point
			if(old_point == nil) then
				table.insert(points, i)
				elseif(old_point ~= i) then
				table.insert(points, i)
			end
		end
	end

	local number_point = #points

	if(number_point == 0) then
		return nil
	elseif(number_point == 1) then
		return patrol_path:level_vertex_id(points[1])
	else
		return patrol_path:level_vertex_id(points[math.random(1, number_point)])
	end
end

-- Возвращает индекс самой ближней точки пути с заданым битом, от текущей точки
function near_point_with_bit(point, patrol_path, bit)
	local new_point = nil
	local index = nil
	local dist = 1000.0

	for i = 0, patrol_path:count()-1 do
		if( patrol_path:flag(i, bit) ) then
			if(new_point == nil or patrol_path:point(i):distance_to(point) < dist) then
				-- Если эта точка первая из нашедшихся, либо от нее путь ближе, то запоминаем ее
				new_point = patrol_path:point(i)
				index = i
				dist = new_point:distance_to(point)
			end
		end
	end

	return index
end

-- Рекурсивная распечатка таблицы
function print_table(table, subs)
	local sub
	if subs ~= nil then
		sub = subs
		else
		sub = ""
	end
	for k,v in pairs(table) do
		if type(v) == "table" then
			printf(sub.."%s:", tostring(k))
			print_table(v, sub.."    ")
		elseif type(v) == "function" then
			printf(sub.."%s:function", tostring(k))
		elseif type(v) == "userdata" then
			printf(sub.."%s:userdata", tostring(k))
		elseif type(v) == "boolean" then
			if v == true then
				printf(sub.."%s:true", tostring(k))
			else
				printf(sub.."%s:false", tostring(k))
			end
		else
			if v ~= nil then
				printf(sub.."%s:%s", tostring(k),v)
			else
				printf(sub.."%s:nil", tostring(k),v)
			end
		end
	end
end

function store_table(table, subs)
	local sub
	if subs ~= nil then
		sub = subs
	else
		sub = ""
	end
	printf(sub.."{")
	for k,v in pairs(table) do
		if type(v) == "table" then
			printf(sub.."%s = ", tostring(k))
			store_table(v, sub.."    ")
		elseif type(v) == "function" then
			printf(sub.."%s = \"func\",", tostring(k))
		elseif type(v) == "userdata" then
			printf(sub.."%s = \"userdata\",", tostring(k))
		elseif type(v) == "string" then
			printf(sub.."%s = \"%s\",", tostring(k), tostring(v))
		else
			printf(sub.."%s = %s,", tostring(k), tostring(v))
		end
	end
	printf(sub.."},")
end

-------------------------------------------------------------------------------------------

function switch_online (id)
	if id == -1 then return end
	local sim = alife ()
	if sim ~= nil then
		sim:set_switch_online(id, true)
		sim:set_switch_offline(id, false)
	end
end

-------------------------------------------------------------------------------------------

function switch_offline (npc)
	if npc == nil or npc:alive () == false then return end
	local sim = alife ()
	if sim ~= nil then
		sim:set_switch_online(npc:id (), false)
		sim:set_switch_offline(npc:id (), true)
	end
end

-------------------------------------------------------------------------------------------

function get_actor_id()
	if(level.actor() == nil) then return -1 end
	return level.actor():id()
end

-------------------------------------------------------------------------------------------

local monster_classes = {}
local stalker_classes = {}
local trader_classes = {}
local weapon_classes = {}
local weapon_only_classes = {}
local artefact_classes = {}
------------------------------------------------------Kirgudu_start
local food_classes = {}
local medical_classes = {}
local ammo_classes = {}
------------------------------------------------------Kirgudu_end
------------------------------------------------------makdm_start
local detector_classes = {}
local outfit_classes = {}
local weapon_reload_classes = {}

function IsDetector(object, class_id)
	local id = class_id or get_clsid(object)
	return detector_classes[id] == true
end

function IsOutfit(object, class_id)
	local id = class_id or get_clsid(object)
	return outfit_classes[id] == true
end

function IsWeapon_reload(object, class_id)
	local id = class_id or get_clsid(object)
	return weapon_reload_classes[id] == true
end
---------------------------------------------------------makdm_end
function IsMonster (object, class_id)
	local id = class_id or get_clsid(object)
	return monster_classes[id] == true
end

function IsStalker (object, class_id)
	local id = class_id or get_clsid(object)
	return stalker_classes[id] == true
end

function isWeapon(object, class_id)
	local id = class_id or get_clsid(object)
	return weapon_classes[id] == true
end

function isWeaponOnly(object, class_id)
	local id = class_id or get_clsid(object)
	return weapon_only_classes[id] == true
end

function isArtefact(object, class_id)
	local id = class_id or get_clsid(object)
	return artefact_classes[id] == true
end

function IsTrader(object, class_id)
	local id = class_id or get_clsid(object)
	return trader_classes[id] == true
end
------------------------------------------------------Kirgudu_start
function IsFood(object, class_id)
	local id = class_id or get_clsid(object)
	return food_classes[id] == true
end

function IsMedical(object, class_id)
	local id = class_id or get_clsid(object)
	return medical_classes[id] == true
end

function IsAmmo(object, class_id)
	local id = class_id or get_clsid(object)
	return ammo_classes[id] == true
end
------------------------------------------------------Kirgudu_end
-------------------------------------------------------------------------------------------

-- получить геймобжект по стори_айди.
function level_object_by_sid( sid )
	local sim = alife()

	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return level.object_by_id( se_obj.id )
		end
	end

	return nil
end

-- Получить айдишник обьекта по стори айди.
function id_by_sid( sid )
	local sim = alife()

	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return se_obj.id
		end
	end

	return nil
end

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	local reason = string.format(fmt, ...)
	assert("ERROR: " .. reason)
	error_log("ERROR: " .. reason)
	dbglog(fmt, ...)
	log(string.format("%s",nil))
end

ASSERT = function(condition, fmt, ...)
	if not condition then abort("<ASSERT>:"..tostring(fmt), ...) end
end

function set_postprocess(name_ini_file)
	bind_stalker.post_process = postprocess.PostProcess(ini_file(name_ini_file))
end

function remove_postprocess()
	bind_stalker.post_process = nil
end

function set_inactivate_input_time(delta)
	db.storage[db.actor:id()].disable_input_time = game.get_game_time()
	db.storage[db.actor:id()].disable_input_idle = delta
	level.disable_input()
end

-- Принимает: позицию положения, позицию куда смотреть, время сна в минутах.
function set_sleep_relocate(point, look, timeout)
	db.storage[db.actor:id()].sleep_relocate_time = game.get_game_time()
	db.storage[db.actor:id()].sleep_relocate_idle = timeout*60
	db.storage[db.actor:id()].sleep_relocate_point = point
	db.storage[db.actor:id()].sleep_relocate_look = look

	--set_inactivate_input_time(timeout*60)
	--db.actor:actor_sleep(0, timeout)
end

-- Проверяет целую часть числа на нечётность
function odd(x)
	return math.floor( x * 0.5 ) * 2 == math.floor( x )
end


--' Находится ли NPC во фруструме игрока
function npc_in_actor_frustrum(npc)
	local actor_dir = device().cam_dir
	--local actor_dir = db.actor:direction()
	local npc_dir = npc:position():sub(db.actor:position())

	local yaw = yaw_degree3d(actor_dir, npc_dir)
	--printf("YAW %s", tostring(yaw))

	return yaw < 35
end

--' Усталость
function on_actor_critical_power()
end

function on_actor_critical_max_power()
end

--' Кровотечение
function on_actor_bleeding()
end

function on_actor_satiety()
end

--' Радиация
function on_actor_radiation()
end

--' Заклинило оружие
function on_actor_weapon_jammed()
end

--' Не может ходить из-за веса
function on_actor_cant_walk_weight()
end

--' Пси воздействие
function on_actor_psy()
end

function set_actor_rank(rank)
	if rank == "novice" then
		db.actor:set_character_rank(0)
	elseif rank == "stalker" then
		db.actor:set_character_rank(300)
	elseif rank == "veteran" then
		db.actor:set_character_rank(600)
	elseif rank == "master" then
		db.actor:set_character_rank(900)
	end
end

function get_texture_info(id_name, id_default)
	if id_default == nil then id_default = id_name end

	local task_info = GetTextureInfo(id_name, id_default)
	local r = task_info:get_rect()

	r.x2 = r.x2 - r.x1
	r.y2 = r.y2 - r.y1
	return task_info:get_file_name(), r
end

function start_game_callback()
	aa = alife()

	monster_classes = {
		[clsid.bloodsucker_s] = true,
		[clsid.boar_s] = true,
		[clsid.dog_s] = true,
		[clsid.flesh_s] = true,
		[clsid.pseudodog_s] = true,
		[clsid.burer_s] = true,
		[clsid.cat_s] = true,
		[clsid.chimera_s] = true,
		[clsid.controller_s] = true,
		[clsid.fracture_s] = true,
		[clsid.poltergeist_s] = true,
		[clsid.gigant_s] = true,
		[clsid.zombie_s] = true,
		[clsid.snork_s] = true,
		[clsid.tushkano_s] = true,
		[clsid.psy_dog_s] = true,
		[clsid.psy_dog_phantom_s] = true
	}

	stalker_classes = {
		[clsid.script_actor] = true,
		[clsid.script_stalker] = true
	}

	trader_classes = {
		[clsid.trader] = true,
		[clsid.script_trader] = true
	}

	weapon_classes = {
		[clsid.wpn_vintorez_s] = true,
		[clsid.wpn_ak74_s] = true,
		[clsid.wpn_lr300_s] = true,
		[clsid.wpn_hpsa_s] = true,
		[clsid.wpn_pm_s] = true,
		[clsid.wpn_shotgun_s] = true,
		[clsid.wpn_bm16_s] = true,
		[clsid.wpn_svd_s] = true,
		[clsid.wpn_svu_s] = true,
		[clsid.wpn_rpg7_s] = true,
		[clsid.wpn_val_s] = true,
		[clsid.wpn_walther_s] = true,
		[clsid.wpn_usp45_s] = true,
		[clsid.wpn_groza_s] = true,
		[clsid.wpn_knife_s] = true,
		[clsid.wpn_grenade_launcher] = true,
		[clsid.wpn_grenade_f1] = true,
		[clsid.wpn_grenade_rpg7] = true,
		[clsid.wpn_grenade_rgd5] = true,
		[clsid.wpn_grenade_fake] = true,
		[clsid.wpn_rg6_s] = true
	}

	weapon_only_classes = {
		[clsid.wpn_vintorez_s] = true,
		[clsid.wpn_ak74_s] = true,
		[clsid.wpn_lr300_s] = true,
		[clsid.wpn_hpsa_s] = true,
		[clsid.wpn_pm_s] = true,
		[clsid.wpn_shotgun_s] = true,
		[clsid.wpn_bm16_s] = true,
		[clsid.wpn_svd_s] = true,
		[clsid.wpn_svu_s] = true,
		[clsid.wpn_rpg7_s] = true,
		[clsid.wpn_val_s] = true,
		[clsid.wpn_walther_s] = true,
		[clsid.wpn_usp45_s] = true,
		[clsid.wpn_groza_s] = true,
		[clsid.wpn_rg6_s] = true
	}

	artefact_classes = {
		[clsid.art_bast_artefact] = true,
		[clsid.art_black_drops] = true,
		[clsid.art_dummy] = true,
		[clsid.art_electric_ball] = true,
		[clsid.art_faded_ball] = true,
		[clsid.art_galantine] = true,
		[clsid.art_gravi] = true,
		[clsid.art_gravi_black] = true,
		[clsid.art_mercury_ball] = true,
		[clsid.art_needles] = true,
		[clsid.art_rusty_hair] = true,
		[clsid.art_thorn] = true,
		[clsid.art_zuda] = true,
		[clsid.artefact] = true,
		[clsid.artefact_s] = true
	}
--------------------------------------------------------------------makdm_start		
	weapon_reload_classes = {
		[clsid.wpn_vintorez_s] = true,
		[clsid.wpn_ak74_s] = true,
		[clsid.wpn_lr300_s] = true,
		[clsid.wpn_hpsa_s] = true,
		[clsid.wpn_pm_s] = true,
		[clsid.wpn_shotgun_s] = true,
		[clsid.wpn_bm16_s] = true,
		[clsid.wpn_svd_s] = true,
		[clsid.wpn_svu_s] = true,
		[clsid.wpn_rpg7_s] = true,
		[clsid.wpn_val_s] = true,
		[clsid.wpn_walther_s] = true,
		[clsid.wpn_usp45_s] = true,
		[clsid.wpn_groza_s] = true,
		[clsid.wpn_rg6_s] = true
	}
		
	outfit_classes = {
		[clsid.equ_exo] = true,
		[clsid.equ_military] = true,
		[clsid.equ_scientific] = true,
		[clsid.equ_stalker] = true,
		[clsid.equ_stalker_s] = true
	}
		
	detector_classes = {
		--[56] = true,
		[53] = true,
		[54] = true,
		[55] = true}
----------------------------------------------------------------------makdm_end	
------------------------------------------------------Kirgudu_start	
	ammo_classes = {
		[clsid.wpn_ammo] = true,
		[clsid.wpn_ammo_m209] = true,
		[clsid.wpn_ammo_og7b] = true,
		[clsid.wpn_ammo_vog25] = true
	}
		
	food_classes = {
		[clsid.obj_food] = true
	}

	medical_classes = {
		[clsid.obj_medkit] = true
	}
------------------------------------------------------Kirgudu_end
	printf("start_game_callback called")
	smart_names.init_smart_names_table()
	task_manager.clear_task_manager()
	treasure_manager.load_treasures()

	sound_theme.load_sound()
	xr_sound.start_game_callback()

	dialog_manager.fill_phrase_table()
	xr_s.init()                              --' Distemper 03.2008 --
	sim_objects.clear()
	sim_board.clear()

	sr_light.clean_up ()

	Set_Game_StartTime() --/ set game time

	m_netpk.attach()
	se_stor.attach() -- инициализация модуля se_stor

	prefetch("ogsm") --/ подключение модуля ogsm
	if (ogsm) then bInit = ogsm.on_start_game() end --/#!# инициализация главного модуля мода

	-- Tестирование оптимизации
	--local test_object = test_object.test_object_class()
	--test_object:test()
end

function gi (info)
	db.actor:give_info_portion(info)
end

ammo_section = {}
ammo_section["ammo_9x18_fmj"] = true
ammo_section["ammo_9x18_pbp"] = true
ammo_section["ammo_9x18_pmm"] = true
ammo_section["ammo_9x19_fmj"] = true
ammo_section["ammo_9x19_pbp"] = true
ammo_section["ammo_5.45x39_fmj"] = true
ammo_section["ammo_5.45x39_ap"] = true
ammo_section["ammo_5.56x45_ss190"] = true
ammo_section["ammo_5.56x45_ap"] = true
ammo_section["ammo_5.7x28_fmj"] = true
ammo_section["ammo_5.7x28_ap"] = true
ammo_section["ammo_7.62x54_7h1"] = true
ammo_section["ammo_7.62x54_ap"] = true
ammo_section["ammo_7.62x54_7h14"] = true
ammo_section["ammo_9x39_pab9"] = true
ammo_section["ammo_gauss"] = true
ammo_section["ammo_9x39_ap"] = true
ammo_section["ammo_9x39_sp5"] = true
ammo_section["ammo_11.43x23_fmj"] = true
ammo_section["ammo_11.43x23_hydro"] = true
ammo_section["ammo_12x70_buck"] = true
ammo_section["ammo_12x76_dart"] = true
ammo_section["ammo_12x76_zhekan"] = true
ammo_section["ammo_pkm_100"] = true
ammo_section["ammo_7.62x39_fmj"] = true
ammo_section["ammo_7.62x39_ap"] = true
ammo_section["ammo_7.62x25_fmj"] = true
ammo_section["ammo_7.62x25_ap"] = true
ammo_section["ammo_10.9x32.5"] = true
ammo_section["ammo_og-7b"] = true
ammo_section["ammo_vog-25p"] = true
ammo_section["ammo_vog-25"] = true
ammo_section["ammo_m209"] = true

quest_section = {}
-- преобразует строку в соответствии со значением
function get_param_string(src_string , obj)
	--printf("src_string is [%s] obj name is [%s]", tostring(src_string), obj:name())
	local script_ids = db.script_ids[obj:id()]
	local out_string, num = string.gsub(src_string, "%$script_id%$", tostring(script_ids))
	if num > 0 then
		return out_string , true
	else
		return src_string , false
	end
end

local save_markers = {}

-- Функции для проверки корректности сейв лоад
function set_save_marker(p, mode, check, prefix)

	-- Определяем ключ маркера.
	local result = ""
	--	if debug ~= nil then
	--		local info_table = debug.getinfo(2)
	--		local script_name = string.gsub(info_table.short_src, "%.script", "")
	--		script_name = string.gsub(script_name, "gamedata\\scripts\\", "")
	--		result = script_name
	--	end

	--	if prefix ~= nil then
	result = result .. "_" .. prefix
	--	end

	if check == true then
		if save_markers[result] == nil then
			abort("Trying to check without marker %s", result)
		end

		if mode == "save" then
			local dif = p:w_tell() - save_markers[result]
			printf(result..": SAVE DIF: %s", dif)
			if dif >= 8000 then
				printf("WARNING! may be this is problem save point")
			end
			if dif >= 10240 then
				abort("You are saving too much")
			end
			p:w_u16(dif)
		else
			local c_dif = p:r_tell() - save_markers[result]
			local dif = p:r_u16()
			if dif ~= c_dif then
			 	abort("INCORRECT LOAD [%s].[%s][%s]", result, dif, c_dif)
			else
				printf(result..": LOAD DIF: %s", dif)
			end
		end
		return
	end

	if mode == "save" then
		printf(result..": set save marker: %s", p:w_tell())
		save_markers[result] = p:w_tell()
		if p:w_tell() > 16000 then
			abort("You are saving too much")
		end
		else
		printf(result..": set load marker: %s", p:r_tell())
		save_markers[result] = p:r_tell()
	end

end
-- переводит вектор в строку.
function vec_to_str (vector)
	if vector == nil then return "nil" end
	return string.format("[%d:%d:%d]", vector.x, vector.y, vector.z)
end
-- выводит в лог стэк вызова функций.
function callstack()
	if debug ~= nil then
		log(debug.traceback(2))
	end
end
-- меняет team:squad:group обьекта.
function change_team_sqaud_group(se_obj, team, squad, group)
	local cl_obj = db.storage[se_obj.id] and db.storage[se_obj.id].object
	if cl_obj ~= nil then
		cl_obj:change_team(team, squad, group)
	else
		se_obj.team = team
		se_obj.squad = squad
		se_obj.group = group
	end
	--printf("_G:TSG: [%s][%s][%s]", tostring(se_obj.team), tostring(se_obj.squad), tostring(se_obj.group))
end

----------
-- Вывод информации в лог
function dbglog(fmt,...)
	local msg = string.format(fmt, ...)
	get_console():execute("load ~~~ " .. msg)
end

----------
-- Вывод таблицы в лог
function dbglog_table(table, subs)
  local sub
  if subs ~= nil then
    sub = subs
		else
    sub = ""
	end
  for k,v in pairs(table) do
    if type(v) == "table" then
      dbglog(sub.."%s:", tostring(k))
      dbglog_table(v, sub.."    ")
			elseif type(v) == "function" then
      dbglog(sub.."%s:function", tostring(k))
			elseif type(v) == "userdata" then
      dbglog(sub.."%s:userdata", tostring(k))
			elseif type(v) == "boolean" then
			if v == true then
				dbglog(sub.."%s:true", tostring(k))
				else
				dbglog(sub.."%s:false", tostring(k))
			end
			else
      if v ~= nil then
        dbglog(sub.."%s:%s", tostring(k),v)
				else
        dbglog(sub.."%s:nil", tostring(k),v)
			end
		end
	end
end

----------
-- Функции времени
-- По материалам: Artos, Garry_Galler
-- Доработка: Kirgudu
----------

----------
-- Получение массива целых значений, представляющих дату и время (для сохранения в storehouse)
-- Адаптация: Kirgudu
-- В случае отсутствия параметра типа CTime берётся нулевое игровое время
function CTimeToTable(dateTime) --/ передаем время CTime
	dateTime = dateTime or game.CTime()
	local Y, M, D, h, m, s, ms = 0, 0, 0, 0, 0, 0, 0
	Y, M, D, h, m, s, ms = dateTime:get(Y, M, D, h, m, s, ms)
	return {Y, M, D, h, m, s, ms}
end

----------
-- Получение значения переменной типа CTime из массива целых значений, представляющего дату и время (для чтения из storehouse)
-- Адаптация: Kirgudu
-- В случае отсутствия параметра типа массив целых чисел берётся нулевое игровое время
function TableToCTime(t) --/ передаем массив аргументов в формате {Y, M, D, h, m, s, ms}.
	local dateTime = game.CTime()
	if t then dateTime:set(t[1], t[2], t[3], t[4], t[5], t[6], t[7]) end
	return dateTime
end

----------
-- Получение строки с датой/временем
-- Авторы оригинала: Artos, Garry_Galler
-- Адаптация: Kirgudu
-- В случае отсутствия второго параметра типа CType берёт текущее игровое время
function Get_StringOnTimeOrDate(sType, dateTime) --/ передаем аргументы из числа "Y", "M", "D", "h", "m", "s", "ms" - по одной штуке - смотря какое значение текущего игрового времени или даты хотим получить - по умолчанию функция возвращает секунды.
	if not dateTime then dateTime = game.get_game_time() end
	if sType then
		local tTime = {
			["Y"]  = game.CTime.DateToYear,    --/ 2012
			["M"]  = game.CTime.DateToMonth, --/ 01/2012
			["D"]  = game.CTime.DateToDay,     --/ 01/01/2012
			["h"]  = game.CTime.TimeToHours,   --/ 23
			["m"]  = game.CTime.TimeToMinutes, --/ 23:59
			["s"]  = game.CTime.TimeToSeconds, --/ 23:59:59
			["ms"] = game.CTime.TimeToMilisecs --/ 23:59:59:999
		}
		if sType == string.lower(sType) then --/ аргумент в нижнем регистре
			return dateTime:timeToString(tTime[sType] or 0) --/> время
		end
		return dateTime:dateToString(tTime[sType] or 0) --/> дата
	end
	return dateTime:timeToString(game.CTime.TimeToSeconds) --/> по дефолту 23:59:59
end

local oCTime_Start    = nil --/ объект счетчика времени в Зоне с момента 'даты старта'
local sini            = system_ini()

--/ Установка 'базового' счетчика игрового времени на дату из 'alife.ltx'
function Set_Game_StartTime()
	local ParseStr = function(str,divider)
		local tbl,pattern = {},'[^%s*%'..(divider or ',')..']+'
		for s in str:gmatch(pattern) do
			table.insert(tbl, tonumber(s) or 0)
		end
		return tbl --/>
	end
	local tT = ParseStr(sini:r_string("alife", "start_time"), ":") --/ 05:30:00
	local tD = ParseStr(sini:r_string("alife", "start_date"), ".") --/ 01.05.2012
	--/ Установка игрового времени. Формат установки: (Y,M,D, h,m,s, ms)
	oCTime_Start = game.CTime() --/ 'нулевое' игровое время (объект класса 'CTime')
	oCTime_Start:set(tD[3],tD[2],tD[1], tT[3],tT[2],tT[1], 0) --/< 2011,09,10, 06,10,00, 0
end

--/ установка счетчика игрового времени на iSeconds
function set_seconds2ctime(iSeconds, oCTime)
	if not oCTime then oCTime = game.CTime() end --/ если счетчик не задан - берем 'нулевой'
	local s,ms = math.modf(iSeconds or 0)
	if ms < 0.001 then
		oCTime:setHMS(0,0,s)
	else
		oCTime:setHMSms(0,0,s, math.floor(ms*1000))
	end
	return oCTime --/>
end

--/ установка счетчика текущего игрового времени на iSeconds
function Set_Rest_GameSeconds(iSeconds, oCTime)
	oCTime = set_seconds2ctime(iSeconds, oCTime)
	oCTime:add(game.get_game_time())
	return oCTime --/>
end

--/ доустановка счетчика игрового времени на iSeconds
function Add_Rest_GameSeconds(iSeconds, oCTime)
	if oCTime then
		oCTime_Add = set_seconds2ctime(iSeconds)
		oCTime:add(oCTime_Add)
	else
		oCTime = Set_Rest_GameSeconds(iSeconds)
	end
	return oCTime --/>
end

--/ оставшееся время в игровых секундах от заданного 'oCTime' (или от момента начала игры)
function Get_Rest_GameSeconds(oCTime)
	local iDiffSec = (oCTime or oCTime_Start):diffSec( game.get_game_time() )
	-- if oCTime and iDiffSec < -10^8 then --/#?#  for debug CTime
		-- log("%s:Get_Rest_GameSeconds:DiffSec=[%s]:(%s):<%s>", sModule, iDiffSec, type(oCTime), "Warning!") --/#~#
		-- print("Get_Rest_GameSeconds:DiffSec=["..iDiffSec.."]:("..type(oCTime).."):<Warning!>") --/#~#
	-- end
	return iDiffSec --/> game-seconds (float)
end

--/ прошедшее время в игровых секундах (с момента начала игры или от заданного)
function Get_Past_GameSeconds(oCTime)
	local iDiffSec = game.get_game_time():diffSec(oCTime or oCTime_Start)
	-- if oCTime and iDiffSec > 10^8 then --/#?# for debug CTime
		-- log("%s:Get_Past_GameSeconds:DiffSec=[%s]:(%s):<%s>", sModule, iDiffSec, type(oCTime), "Warning!") --/#~#
		-- print("Get_Past_GameSeconds:DiffSec=["..iDiffSec.."]:("..type(oCTime).."):<Warning!>") --/#~#
	-- end
	return iDiffSec --/> game-seconds (float)
end

--/ прошедшее время в игровых минутах (с момента начала игры или от заданного)
function Get_Past_GameMinutes(oCTime)
	return math.floor(Get_Past_GameSeconds(oCTime)/60) --/> game-minutes
end

--/ прошедшее время в игровых часах (с момента начала игры или от заданного)
function Get_Past_GameHours(oCTime)
	return math.floor(Get_Past_GameSeconds(oCTime)/3600) --/> game-hours
end

----------
-- Вспомогательные функции
-- Kirgudu (по материалам http://lua-users.org/wiki/)
----------

-- выборка из таблицы с сортировкой по key
function __gen_index_ordered(t)
	local index_ordered = {}
	for key in pairs(t) do
		table.insert(index_ordered, key)
	end
	table.sort(index_ordered)
	return index_ordered
end
function next_ordered(t, state)
	if state == nil then
		t.__index_ordered = __gen_index_ordered(t)
		key = t.__index_ordered[1]
		return key, t[key]
	end

	key = nil
	for i = 1,table.getn(t.__index_ordered) do
		if t.__index_ordered[i] == state then
			key = t.__index_ordered[i+1]
		end
	end

	if key then
		return key, t[key]
	end

	t.__index_ordered = nil
	return
end
function pairs_ordered(t)
	return next_ordered, t, nil
end

-- Выборка из таблицы с сортировкой по value (быстрая сортировка с разбивкой на две части).
-- Работает также в случае если value - тоже таблица (простая).
-- Выводимая таблица представляет собой простой массив, индекс исходной таблицы перемещается в поле "__oldKey".
-- Значения элементов выводимого массива всегда представляют собой таблицу.
-- Если value исходной таблицы представляет собой простое значение - оно перемещается в поле "__oldValue".
-- t - исходная таблица
-- o - порядок сортировки, может принимать значения asc (по возрастанию) или desc (по убыванию), при отсутствии по умолчанию берётся asc.
-- s - значение, по которому должна произойти сортировка. Может принимать вид:
--     "", nil или без параметра - для случаев, когда vаlue представляет собой простое значение. Пример:
--       t = {3,7,1,9,4}; вызов сортировки: t2 = sort_table_by_value(t, "")
--     "key" - для случаев, когда value представляет собой таблицу, указывается название поля этой таблицы для сортировки по нему. Пример:
--       t = {{a=3,b=7,c=1},{a=8,b=2,c=5}}; вызов сортировки: t2 = sort_table_by_value(t, "b")
function sort_table_by_value(t, o, s)
	local function qSort(t, o, s, low, high)
		local i, j, x = low, high, t[math.floor((low+high)/2)]
		while (i <= j) do
			if s == "" then
				if o == "desc" then
					while (t[i]["__oldValue"] > x["__oldValue"]) do i = i + 1 end
					while (t[j]["__oldValue"] < x["__oldValue"]) do j = j - 1 end
				else
					while (t[i]["__oldValue"] < x["__oldValue"]) do i = i + 1 end
					while (t[j]["__oldValue"] > x["__oldValue"]) do j = j - 1 end
				end
			else
				if o == "desc" then
					while (t[i][s] > x[s]) do i = i + 1 end
					while (t[j][s] < x[s]) do j = j - 1 end
				else
					while (t[i][s] < x[s]) do i = i + 1 end
					while (t[j][s] > x[s]) do j = j - 1 end
				end
			end
			if (i <= j) then
				local temp = t[i]
				t[i] = t[j]
				t[j] = temp
				i, j = i + 1, j - 1
			end
		end
		if (low < j) then qSort(t, o, s, low, j) end
		if (i < high) then qSort(t, o, s, i, high) end
	end

	s = s or ""
	if not o or (o ~= "asc" and o ~= "desc") then o = "asc" end
	if not t or type(t) ~= "table" then return nil, "sort_table_by_value: wrong source" end
	if type(s) ~= "string" then return nil, "sort_table_by_value: wrong sort parameter" end
	if t.__oldKey then return nil, "sort_table_by_value: source table already has '__oldKey' field" end
	if t.__oldValue then return nil, "sort_table_by_value: source table already has '__oldValue' field" end
	local t1, t2, low, high = deepcopy(t), {}, 1, 0
	for k,v in pairs(t1) do
		high = high + 1
		local v2 = (type(v) == "table") and v or {__oldValue = v}
		v2.__oldKey = k
		table.insert(t2, v2)
	end
	if high <= 1 then return t2, nil end
	qSort(t2, o, s, low, high)
	return t2, nil
end

-- Глубокое копирование любого объекта, включая таблицу, по значению
function deepcopy(object)
	local lookup_table = {}
	local function _copy(object)
		if type(object) ~= "table" then
			return object
		elseif lookup_table[object] then
			return lookup_table[object]
		end
		local new_table = {}
		lookup_table[object] = new_table
		for index, value in pairs(object) do
			new_table[_copy(index)] = _copy(value)
		end
		return setmetatable(new_table, _copy(getmetatable(object)))
	end
	return _copy(object)
end

-- Случайная выборка из простого массива
function randomlist(source, count)
	math.randomseed(time_global())
	local newlist = {}
	if not count then
		count = 0
	else
		count = #source - count
	end
	while #source > count do
		local idx = math.random(1, #source)
		newlist[#newlist + 1] = source[idx]
		table.remove(source, idx)
	end
	return newlist
end

-- Очистка строки от начальных и конечных пробелов
local match = string.match
function string:trim()
	return match(self,'^()%s*$') and '' or match(self,'^%s*(.*%S)')
end

-- Разбивка строки по НАБОРУ РАЗДЕЛИТЕЛЕЙ sep, вывод в виде списка строк. Начальные и конечные пробелы обрезаются.
function string:split_sep(sep, clear)
	local t = {}
	self:gsub("([^"..(sep or ":").."]+)", function(c) t[#t + 1] = c:trim() end)
	return t
end

-- Разбивка строки по СТРОКЕ sep, вывод в виде списка строк. Начальные и конечные пробелы обрезаются.
function string:split(sep, clear)
	local t = {}
	local pattern = "(.-)".. (sep or ":")
	local function helper(line) t[#t + 1] = line:trim() return "" end
	helper((self:gsub(pattern, helper)))
	return t
end

-- Разбивка строки по разделителю "(\r)\n", вывод в виде списка строк
function string:lines()
	local t = {}
	local function helper(line) t[#t + 1] = line return "" end
	helper((self:gsub("(.-)\r?\n", helper)))
	return t
end

-- Разбивка строки по максимальной длине, вывод в виде одной строки с разделителем "\n"
-- limit - максимальная длина строки
-- indent - отступ первой строки после разбивки (строка)
-- indent1 - отступ второй и последующих строк после разбивки (строка)
function string:wrap(limit, indent, indent1)
	indent = indent or ""
	indent1 = indent1 or indent
	limit = limit or 72
	local here = 1 - #indent1
	return indent1..self:gsub("(%s+)()(%S+)()",
		function(sp, st, word, fi)
			if fi-here > limit then
				here = st - #indent
				return "\n"..indent..word
			end
		end)
end

-- Разбивка строки по максимальной длине без учёта пробелов (с разрывом слов), вывод в виде списка строк
-- limit - максимальная длина слова на одной строке
function string:wrap_fixed(limit)
	local t = {}
	if not limit or limit <= 0 then
		table.insert(t, self)
		return t
	end
	while self:len() > limit do
		table.insert(t, self:sub(1, limit))
		self = self:sub(limit + 1)
	end
	if self:len() > 0 then
		table.insert(t, self)
	end
	return t
end

-- Полная разбивка строки по разделителю и максимальной длине, вывод в виде списка строк
-- separator - разделитель (строка)
-- limit - максимальная длина строки
-- indent - отступ первой строки после разбивки (строка)
-- indent1 - отступ второй и последующих строк после разбивки (строка)
function string:wrap_full(separator, limit, indent, indent1)
	local t, ar = {}, self:split(separator)
	for k,v in pairs(ar) do
		v = v:wrap(limit, indent, indent1):lines()
		for kk,vv in pairs(v) do
			vv = vv:wrap_fixed(limit)
			for kkk,vvv in pairs(vv) do
				table.insert(t, vvv)
			end
		end
	end
	return t
end

local tMarkers = { --/ служебная таблица маркеров упаковки
	dec = {string.char(1), 1}, --/ 0x1 (SOH) - 'number' (dec)
	str = {string.char(2), 2}, --/ 0x2 (STX) - 'string'
	bln = {string.char(3), 3}, --/ 0x3 (ETX) - 'boolean'
	tbl = {string.char(4), 4}, --/ 0x4 (EOT) - 'table'
	tbe = {string.char(5), 5}, --/ 0x5 (ENQ) - table-end
	tbi = {string.char(6), 6}, --/ 0x6 (ACK) - table-list
	hex = {string.char(7), 7}, --/ 0x7 (BEL) - number-hex
	vec = {string.char(8), 8}, --/ 0x8 (BS)  - 'vector'
	ctm = {string.char(9), 9}  --/ 0x9 (...) - 'ctime'
}
local tTypeToMarker = { ['nil']=0,['boolean']=1,['number']=2,['string']=3,['table']=4 }

--/--------------------------------------------------------
--/ упаковка таблицы (списка) 'tTbl' в строку 'sStr'
--/--------------------------------------------------------
function fTbl_Compress(tTbl,recur) --/< table [,(nil|true|false)]
	if type(tTbl) ~= 'table' then
		if type(tTbl) == 'userdata' then --/ if 'vector' or 'ctime'?
			if type(tTbl.getP) == 'function' and tonumber(tTbl.x) and tonumber(tTbl.y) and tonumber(tTbl.z) then --/ 'vector'
				-- if db.is_dbg1 then log("fTbl_Compress:vec_marker(%d)=[%s]", tMarkers.vec[2], tMarkers.vec[1], "") end --/#~# 'vector'
				return tMarkers.vec[1] .. fTbl_Compress({tTbl.x,tTbl.y,tTbl.z},recur or {}) .. tMarkers.tbe[1] --/> рекурсивный вызов
			elseif type(tTbl.setHMSms) == 'function' then --/ 'ctime'
				-- if db.is_dbg1 then log("fTbl_Compress:ctm_marker(%d)=[%s]", tMarkers.ctm[2], tMarkers.ctm[1], "") end --/#~# 'ctime'
				local Y,M,D,h,m,s,ms = tTbl:get(0,0,0,0,0,0,0)
				return tMarkers.ctm[1] .. fTbl_Compress({Y,M,D,h,m,s,ms},recur or {}) .. tMarkers.tbe[1] --/> рекурсивный вызов
			end
		end
		-- to_log("fTbl_Compress:Not_Table=["..type(tTbl).."]:<Warning!>")
		return "",true --/> zero-string & error (не таблица!)
	elseif getmetatable(tTbl) then --/ can not serialize a table that has a metatable associated with it.
		-- to_log("fTbl_Compress:metatable:<%s>", "Warning!")
		return "",true --/> zero-string & error (не таблица!)
	elseif not next(tTbl) then --/ --/>? (отсутствует 1-й элемент таблицы)
		return "",false --/> zero-string (таблица пуста)
	end
	recur = recur or {}
	--/-------------------
	--/ локальная функция: проверка типа таблицы:'список' или нет?
	--/-------------------
	local fIs_List = function(tTbl)
		local bList = false
		local iCntIdx = #tTbl --/ длина индексированной части таблицы
		if iCntIdx > 0 then --/ есть элементы списка?
			--/ индексы начинаются с 1 и за 'списком' отсутствует хеш-элемент
			if next(tTbl) == 1 and not next(tTbl,iCntIdx) then
				for i=2,iCntIdx-1 do --/ цикл перепроверки: 'отсутствуют пустые элементы?'
					if tTbl[i] == nil then --/ пустышка?
						return false --/> не список
					end
				end
				bList = true --/ флаг: это список!
			end
		end
		return bList --/> флаг: список или ... (true|nil)
	end
	--/-------------------
	--/ локальная функция: упаковка (+конвертер) числа (number) в 'dec' или 'hex' строку (string)
	--/-------------------
	local fPack_Num2Str = function(iNum)
		if iNum == math.modf(iNum) then --/ целочисленное? (отсутствует дробная часть)
			local iAbs = math.abs(iNum) --/ модуль числа
			if iAbs > 9 then --/ число 2-x и более разрядное?
				local iLv = math.floor(math.log10(iAbs+1)) --/ степень ближайшего к модулю бОльшего числа кратного 10-ти
				if iAbs >= 10^iLv and iAbs < 2^(4*iLv) then --/ разрядность 'dec' > 'hex'?
					if iNum >= 0 then --/ не отрицательное?
						return tMarkers.hex[1] .. string.format('%X', iAbs) --/> 'hex'-строка
					end
					--/ отрицательное - упаковываем со знаком
					return tMarkers.hex[1] .. "-" .. string.format('%X', iAbs) --/> 'hex'-строка со знаком
				end
			end
		end
		return tMarkers.dec[1] .. iNum --/> 'dec'-строка
	end
	--/-------------------
	--/ локальная функция: упаковка ключа (индекса) элемента таблицы
	--/-------------------
	local fPack_Key = function(key)
		local marker = tTypeToMarker[type(key)] or -1 --/ 0...4
		if     marker == 2 then --/ 'number'
			return fPack_Num2Str(key) --/> 'dec|hex'-строка
		elseif marker == 3 then --/ 'string'
			return tMarkers.str[1] .. key --/> строка
		end
		--table.print(tTbl,sModule..":PackTbl|Key")
		--abort("fTbl_Compress:fPack_Key:Type(%s)=[%s]~UnSupported:<%s>", key, type(key), "Error!")
		-- to_log("fTbl_Compress:fPack_Key:Type("..tostring(key)..")=["..type(key).."]~unsupported:<Warning!>")
		return nil,true --/> nil & error
	end
	--/-------------------
	--/ локальная функция: упаковка значения элемента таблицы
	--/-------------------
	local fPack_Value = function(value)
		local marker = tTypeToMarker[type(value)] or -1 --/ 0...4
		if     marker == 2 then --/ 'number'
			return fPack_Num2Str(value) --/> 'dec|hex'-строка
		elseif marker == 3 then --/ 'string'
			return tMarkers.str[1] .. value --/> строка
		elseif marker == 1 then --/ 'boolean'
			return tMarkers.bln[1] .. ((value and "1") or "0") --/> 'bool'-строка ('0'|'1')
		elseif getmetatable(value) then
			--/ can not serialize a table
		elseif marker == 4 then --/ 'table'
			--[[
			if recur[tTbl] then --/ can not serialize recursive tables
				return nil, true --/> nil & error #???#
			end
			--]]
			recur[tTbl] = true
			return tMarkers.tbl[1] .. fTbl_Compress(value,recur) .. tMarkers.tbe[1] --/> рекурсивный вызов
		end
		--table.print(tTbl,sModule..":PackTbl|Value")
		--abort("fTbl_Compress:fPack_Value:Type(%s)=[%s]~UnSupported:List=[%s]:<%s>", value, type(value), bList, "Error!")
		-- to_log("fTbl_Compress:fPack_Value:Type=["..type(value).."]~unsupported:bList=["..tostring(bList).."]:<Warning!>")
		return nil,true --/> nil & error
	end
	--/ -------------------------------------------
	--/ тело основной функции: all pack
	--/-------------------
	local tPackStr = {} --/ временная таблица для частей общей строки
	local key,val,err
	if fIs_List(tTbl) then --/ упаковывается список?
		table.insert( tPackStr, tMarkers.tbi[1] ) --/< маркер 'list' (список)
		for i=1,#tTbl do
			val,err = fPack_Value(tTbl[i],recur)
			if err then
				-- to_log(string.exformat("fTbl_Compress:val(%s)=[%s]=>[%s]~wrong_pack:list:<%s>", type(tTbl[i]), tTbl[i], val, "Warning!"))
				return "",true --/> zero-string & error (can not serialize)
			end
			table.insert(tPackStr, val)
		end
	else --/ полная упаковка (ключ и значение)
		for k,v in pairs(tTbl) do
			key,err = fPack_Key(k,recur)
			if err then
				-- to_log(string.exformat("fTbl_Compress:key(%s)=[%s]=>[%s]~wrong_pack:<%s>", k, type(k), key, "Warning!"))
				return "",true --/>  zero-string & error (can not serialize)
			end
			table.insert(tPackStr, key)
			val,err = fPack_Value(v,recur)
			if err then
				-- to_log(string.exformat("fTbl_Compress:val(%s)=[%s]=>[%s]~wrong_pack:<%s>", v, type(v), val, "Warning!"))
				return "",true --/>  zero-string & error (can not serialize)
			end
			table.insert(tPackStr, val)
		end
	end
	return table.concat(tPackStr) --/> строка
end

--/--------------------------------------------------------
--/ Pаспаковка строки 'sString' в таблицу
--/--------------------------------------------------------
function fTbl_deCompress(sString)
	local iLen = sString:len() --/ длина строки
	--/-------------------
	--/ локальная функция: по-символьный парсер строки 'sString' от iSym-го до 1-го 'управляющего' символа
	--/-------------------
	local fGet_Str = function(iSym) --/< текущий индекс символа в строке
		for i=iSym,iLen do
			local iByte = string.byte(sString:sub(i,i)) --/ код i-го символа строки
			if iByte < 32 then --/ 'управляющий' символ?
				if iByte > 9 then --/ запрещенный 'управляющий' символ?
					abort(script_name()..":fTbl_deCompress:fGet_Str:Symbol("..tostring(i)..")=["..tostring(iByte).."] < 32:<Error!>")
				elseif i == iSym then --/ текущий символ такой же как и начальный управляющий символ?
					if i > 0 and iByte ~= tMarkers.str[2] and iByte == string.byte(sString:sub(i-1,i-1)) then --/ исключаем пустые строки
						-- to_log("fTbl_deCompress:fGet_Str:string= "..tostring(sString))
						abort(script_name()..":fTbl_deCompress:fGet_Str:Symbol("..tostring(i)..")=["..tostring(iByte).."]:<Error!>")
					else
						-- to_log("fTbl_deCompress:fGet_Str: symbol=["..tostring(i).."] <~ zero string") --/#~#
					end
				end
				return sString:sub(iSym,i-1),i --/> sStr,iNext (субстрока и индекс начального упр.символа)
			end
		end
		return sString:sub(iSym,iLen) --/> sStr (субстрока до конца строки)
	end
	--/-------------------
	--/ локальная функция: конвертер субстроки (sStr) в десятичное число
	--/-------------------
	local fGet_Num = function(sStr,bHex) --/< bHex - флаг 'hex'-строки
		local iNum = nil
		if not bHex then --/ распаковки 'dec'-строки?
			iNum = tonumber(sStr) --/ перевод 'dec'-строки в десятичное число
		else --/ распаковка 'hex'-строки
			if sStr:sub(1,1) ~= "-" then --/ отсутствует символ '-' (минус)?
				iNum = tonumber(sStr,16) --/ перевод 'hex'-строки в десятичное число ('0x'..sStr)
			else --/ для отрицательного - отрезаем 1-й символ
				iNum = tonumber(sStr:sub(2,-1),16) *(-1) --/ перевод 'hex'-строки в отрицательное десятичное число
			end
		end
		if not iNum then --/ ошибка распаковки числа?
			abort(script_name()..":fTbl_deCompress:fGet_Num:Str=["..tostring(sStr).."],Hex=["..tostring(bHex).."]:<Error!>")
		end
		return iNum --/> number
	end
	--/ -------------------------------------------
	--/ тело основной функции: parse all
	--/-------------------
	fParse = function(iSym) --/< парсинг строки 'sString' с iSym-го символа
		-- log("fTbl_deCompress:fParse:at=[%s],Len=[%s],String=[%s]", iSym, iLen, sString, '') --/#~#
		local bVector,bCTime = nil,nil --/ if 'vector' or 'CTime'
		--/ проверка: упакована таблица типа 'список' (table-list)?
		local iByte = string.byte(sString:sub(iSym,iSym)) --/ код iSym-го символа в строке
		iSym = iSym+1 --/ переходим к следующему символу
		local bList = iByte == tMarkers.tbi[2] --/ флаг: 'начало списка' (table-list)
		if bList then --/ проверка: 'список'?
			iByte,iSym = string.byte(sString:sub(iSym,iSym)), iSym+1--/ пропускаем маркер списка и переходим к следующему символу
		else
			bVector,bCTime = iByte == tMarkers.vec[2], iByte == tMarkers.ctm[2]
			if bVector or bCTime then --/ if 'vector' or 'CTime'
				bList = string.byte(sString:sub(iSym,iSym)) == tMarkers.tbi[2] --/ флаг: 'начало списка' (table-list)
				if not bList then --/ проверка: 'список'?
					abort("fTbl_deCompress:fParse:(%d)=[%s],at=(%d)=[%s],String=[%s]~wrong!:<%s>", iByte, string.char(iByte), iSym, string.char(iSym), sString, "Warning!")
				end
			end
		end
		local tTbl,key,value = {},nil,nil
		--/ цикл парсинга строки с iSym-го символа
		while iSym <= iLen do --/ (суб)строка не закончилась?
			if iByte == tMarkers.tbe[2] then --/ проверка: маркер конца субтаблицы (table-end)?
				return tTbl,iSym --/> субстрока субтаблицы закончилась - выход из функции
			end
			if not bList then --/ проверка: не 'список'? -> режим 'общей' таблицы
				key,iSym = fGet_Str(iSym) --/ парсинг 'key'
				if iByte == tMarkers.dec[2] then --/ 'number' (dec)?
					key = fGet_Num(key, false) --/< распаковка 'dec'-строки
				elseif iByte == tMarkers.hex[2] then --/ 'number-hex'?
					key = fGet_Num(key, true) --/< 'true' - флаг распаковка 'hex'-строки
				elseif iByte ~= tMarkers.str[2] then --/ не 'string'? -> ошибка формата упаковки
					abort("fTbl_deCompress:fParse:at=(%d):UnSupported_TypeKey(%s)=[%d],String=[%s]", iSym, key, iByte, sString)
				end
				iByte,iSym = string.byte(sString:sub(iSym,iSym)), iSym+1 --/ код следующего символа строки
			end
			--/ проверка 'value'
			if iByte == tMarkers.tbl[2] then --/ 'table'?
				value,iSym = fParse(iSym) --/> рекурсивный вызов для 'табличных субстрок'
			elseif bVector then --/ 'vector'?
				value,iSym = fParse(iSym) --/> рекурсивный вызов для 'табличных субстрок'
				if value[3] then
					value = vector():set(unpack(value)) --/ 'vector'
				else
					-- to_log(string.exformat("fTbl_deCompress:fParse:(%d),at=(%d),key(%s):Wrong_DataVector=[%d],String=[%s]", iByte, iSym, #value or -1, sString))
					value = vector():set(0,0,0) --/> 'zero_vector'
				end
			elseif bCTime then --/ 'ctime'?
				value,iSym = fParse(iSym) --/> рекурсивный вызов для 'табличных субстрок'
				local ctime = game.CTime()
				if value[7] then
					value = ctime:set(unpack(value)) --/> 'CTime'
				else
					-- to_log(string.exformat("fTbl_deCompress:fParse:(%d),at=(%d):Wrong_DataCTime=[%d],String=[%s]", iByte, iSym, #value or -1, sString))
					value = ctime --/> 'zero_oCTime'
				end
			else --/ парсинг 'value'
				value,iSym = fGet_Str(iSym) --/ парсинг 'value'
				if     iByte == tMarkers.dec[2] then --/ 'number' (dec)?
					value = fGet_Num(value, false) --/< распаковка 'dec'-строки
				elseif iByte == tMarkers.hex[2] then --/ 'number-hex'?
					value = fGet_Num(value, true) --/< 'true' - флаг распаковка 'hex'-строки
				elseif iByte == tMarkers.bln[2] then --/ 'boolean'?
					value = value == "1"
				elseif iByte ~= tMarkers.str[2] then --/ не 'string'? - ошибка формата упаковки
					abort("fTbl_deCompress:fParse:at=(%d):UnSupported_TypeValue(%s)=[%d],Key=[%s],List=[%s],String=[%s]", iSym, type(value), iByte, tostring(key), tostring(bList), sString)
				end
			end
			--/ запоминаем элемент в таблицу
			-- log("fParse:key=[%s],value=[%s]:[%s]", key, value, "<") --/#~#
			if bList then --/ элемент списка?
				--if not iSym and (bVector or bCTime) then --/#?# конец строки и 'vector' or 'CTime'?
					--return value --/#?#> выход из цикла
				if bVector or bCTime then --/#?# конец строки и 'vector' or 'CTime'?
					tTbl = value
					return tTbl --/#?#> выход из цикла
				end
				table.insert(tTbl, value) --/ добавляем в таблицу типа 'список' (table-list)
			else --/ элементы 'общей' таблицы
				tTbl[key] = value
			end
			if not iSym then --/ конец строки?
				return tTbl --/> выход из цикла
			end
			iByte,iSym = string.byte(sString:sub(iSym,iSym)), iSym+1 --/ код следующего символа строки
		end
		return tTbl,iSym --/> (sub)table or 'vector' or 'CTime'
	end
	--/----------------------------------------------------------------
	--/ парсинг строки 'sString' (с 1-го символа)
	-- log("fTbl_deCompress:Len=[%s],String=[%s]", iLen, sString, '') --/#~#
	return fParse(1) or {} --/> table
end

if not table.compress then --/clench|shrink
	table.compress = fTbl_Compress
end
if not table.decompress then
	table.decompress = fTbl_deCompress
end

----------
-- Вспомогательные функции
-- Kirgudu (по материалам http://lua-users.org/wiki/)
----------

--/----------------------------------------------
--/ конвертер строки для 'printf'
--/ Автор: Artos
--/----------------------------------------------
function FormatToString(fmt,...)
	--/ локальная функция: перевод аргумента в стринг
	local to_str = function(val,typ)
		if typ == 'boolean' then
			return tostring(val) --/>
		elseif typ == 'table' or typ == 'userdata' then
			if tonumber(val.x) and tonumber(val.y) and tonumber(val.z) then
				if typ == 'table' then
					return string.format('tab{x=%.3f:y=%.3f:z=%.3f}',val.x,val.y,val.z) --/>
				end
				return string.format('vec(x=%.3f:y=%.3f:z=%.3f)',val.x,val.y,val.z) --/>
			end
		elseif typ == 'number' then
			return tostring(val) --/>
		elseif typ == 'string' then
			return val --/>
		end
		return "<"..typ..">" --/>
	end
	--/ основное тело функции: парсинг исходной строки
	if type(fmt) == 'string' then
		if fmt:match('%%[sd]') then --/ есть патерн(ы)
			if next({...}) then --/ есть аргумент(ы)?
				local arg,val,typ,i = {...},nil,nil,nil
				for i=1,#arg do
					val = arg[i] --/ значение текущего аргумента
					typ = type(val) --/ тип текущего аргумента
					if typ == 'string' then
						fmt = fmt:gsub('%%s',val,1)
					elseif typ == 'number' then
						if fmt:match('%%d') then
							fmt = fmt:gsub('%%d',val,1)
						else
							fmt = fmt:gsub('%%s',val,1)
						end
					else
						fmt = fmt:gsub('%%s',to_str(val,typ),1)
					end
				end
			end
			fmt = fmt:gsub('%%[sd]',"<NOT_arg!>") --/ заглушка от отсутствия аргументов
		end
	else
		fmt = to_str(fmt,type(fmt))
	end
	--/ с заменой обычных пробелов (sym_space='\032') на печатные ('\160')
	return fmt:gsub('%s','\160') --/>
end

--/------------------------------------------------------------------
--/ Functions for Print-Log
--/ Автор: Artos
--/ Адаптация: Kirgudu
--/------------------------------------------------------------------
local console --/ переменная, кеширующая функцию консоли

function printf_log(fmt,...) --/ вспогательная функция для непосредственно вывода в лог
	if not console then console = get_console() end
	if next({...}) then
		fmt = string.sub(FormatToString(fmt,...),1,250)
		console:execute("load :>"..fmt)
	else
		console:execute("load :>"..string.sub(tostring(fmt),1,250))
	end
end

function printf_p(fmt,...)
	if not console then console = get_console() end
	if debug == nil then
		printf_log(fmt,...)
		return
	end
	local is_g = 0
	local result = fmt
	local info_table = debug.getinfo(2)
	local script_name = string.gsub(info_table.short_src, "%.script", "")
	script_name = string.gsub(script_name, "gamedata\\scripts\\", "")
	if scripts_to_print[script_name] == true then return end
	script_name,is_g = string.gsub(script_name, "_g", "")
	if is_g == 0 then
		result = script_name..":("..info_table.currentline.."):"..fmt
	end
	printf_log(result,...)
end

--/----------------------------------------------
--/ вывод в буфер лога
--/ незначительно нагружает игру, но при фатальных ошибках информация из буфера лога может быть утеряна
--/----------------------------------------------
function printf(fmt,...) --/ в зависимости от настройки hwm_options.full_log
	if not log_full then return end
	printf_p(fmt,...)
end
function printff(fmt,...) --/ всегда (forced)
	printf_p(fmt,...)
end

--/----------------------------------------------
--/ вывод в лог-файл
--/ сохраняет каждую строку в лог-файл в реальном времени, но в циклах и апдейтах может значительно тормозить игру.
--/----------------------------------------------
function print_f(fmt,...) --/ в зависимости от настройки hwm_options.full_log
	if not log_full then return end
	printf_p(fmt,...)
	console:execute("flush")
end
function print_ff(fmt,...) --/ всегда (forced)
	printf_p(fmt,...)
	console:execute("flush")
end

--/-------------------------------------------------------------------
--/#+# initialize extension modules
--/-------------------------------------------------------------------
prefetch("lua_extension") --/#+# подключение модуля расширений Lua
prefetch("lua_helper") --/#+# подключение модуля 'общих' хелп-функций

--/ ------------------------------------------------------------------
--/ print-log (вывод отладочной информации)
--/-------------------------------------------------------------------
local console
--/ функция вывода сообщения в игровую консоль
to_log = debug_print or logf or log1 or function(fmt,...)
	if not log_full then return end
	if not console then console = get_console() end
	console:execute("load ~:"..string.exformat(fmt,...))
end
--/-------------------------------------------------------------------
--/ Принудительное прерывание игры при фатальных ошибках
--/-------------------------------------------------------------------
abort = function(fmt,...)
	to_log(string.rep("~",86))
	assert("[error]ABORT CALLED:\n" .. string.exformat(fmt, ...))
	to_log("[error]ABORT CALLED:")
	to_log(string.exformat(fmt, ...))
	to_log("ATTENTION! Game is interrupted! The information in lines above.")
	to_log(string.rep("~",86))
	get_console():execute('flush')
	exit() --/#!# interrupt game in case of fatal errors
end
--/ ------------------------------------------------------------------
