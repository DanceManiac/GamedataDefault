------------------------- Copyright 2007-2011 DEXXX, xStream --------------------------
---------------------------- Библиотека служебных скриптов ----------------------------
------------------------- Last edit (by Kirgudu): 04.05.2020 --------------------------

dbgset = false
need_jump = false

local r_timers = nil
local g_timers = nil
local need_delayed_otf_fix = false
local can_release = true
local after_load = true
local oNearest = nil --/ время 'ближайшего' таймера
local ALIFE_TIME_FACTOR = nil --/ текущий таймфактор
local fs = getFS()
local iAutoSaveTimeout = 3 --/ отсрочка запуска вызванного автосэйва, в секундах реального времени


-- Записываем переменную
function save_variable(variable_name, value)
	xr_logic.pstor_store_w_table(db.actor, variable_name, value)
end


-- Загружаем переменную
function load_variable(variable_name, value_if_not_found)
	return xr_logic.pstor_retrieve_w_table(db.actor, variable_name, value_if_not_found)
end


-- Удаляем переменную
function del_variable(variable_name)
	xr_logic.pstor_delete(db.actor, variable_name)
end


-- Kirgudu
-- Проверка того, что таймер реального времени с указанным именем существует
function is_timer_exists(name)
	if r_timers == nil then r_timers_first_load() end

	for a=1,99,1 do
		if r_timers[a] and r_timers[a].name == name then
			return true
		end
	end
	return false
end

-- Проверка того, что таймер игрового времени с указанным именем существует
function is_g_timer_exists(name)
	if g_timers == nil then g_timers_first_load() end

	for a=1,99,1 do
		if g_timers[a] and g_timers[a].name == name then
			return true
		end
	end
	return false
end
-- Kirgudu


-- Старт таймера в реальном времени
function start_timer(name,delay,action)
	if not delay then
		return false
	end

	if r_timers == nil then r_timers_first_load() end

	local a=1
	while r_timers[a] ~= nil do
		a=a+1
		if a>99 then
			return false
		end
	end

	if not action then
		action = ""
	end

	if ALIFE_TIME_FACTOR == nil then ALIFE_TIME_FACTOR = level.get_time_factor() end --/ system_ini():r_float("alife", "time_factor")

	local settime = Set_Rest_GameSeconds(delay*ALIFE_TIME_FACTOR)

	save_variable("rt"..a, name)
	save_variable("rt"..a.."d", CTimeToTable(settime))
	save_variable("rt"..a.."p", action)

	r_timers[a] = {name = name, ctime = settime, params = action}

	if not oNearest then oNearest = game.get_game_time() end --/ preset
	if oNearest > settime then
		oNearest = game.CTime(settime) --/ change nearest time
	end

	-- dbglog("timers:> start real> idx=["..a.."], name=["..name.."], action=["..action.."], delay=["..delay.."]")
	-- dbglog("timers:> set time=["..Get_StringOnTimeOrDate("D", settime).." "..Get_StringOnTimeOrDate("s", settime).."], nearest time=["..Get_StringOnTimeOrDate("D", oNearest).." "..Get_StringOnTimeOrDate("s", oNearest).."]")

	return true
end


-- Старт таймера в игровом времени
function g_start_timer(name,delay_d,delay_h,delay_m,action)
	if delay_d==nil or delay_h==nil or delay_m==nil then
		return false
	end

	if g_timers == nil then g_timers_first_load() end

	local a=1
	while g_timers[a] ~= nil do
		a=a+1
		if a>99 then
			return false
		end
	end

	if action==nil then
		action = ""
	end

	local settime = Set_Rest_GameSeconds((delay_d*24*60 + delay_h*60 + delay_m)*60)

	save_variable("gt"..a, name)
	save_variable("gt"..a.."d", CTimeToTable(settime))
	save_variable("gt"..a.."p", action)

	g_timers[a] = {name = name, ctime = settime, params = action}

	if not oNearest then oNearest = game.get_game_time() end --/ preset
	if oNearest > settime then
		oNearest = game.CTime(settime) --/ change nearest time
	end

	-- dbglog("timers:> start game> idx=["..a.."], name=["..name.."], action=["..action.."], delay_d=["..delay_d.."], delay_h=["..delay_h.."], delay_m=["..delay_m.."]")
	-- dbglog("timers:> set time=["..Get_StringOnTimeOrDate("D", settime).." "..Get_StringOnTimeOrDate("s", settime).."], nearest time=["..Get_StringOnTimeOrDate("D", oNearest).." "..Get_StringOnTimeOrDate("s", oNearest).."]")

	return true
end

-- Чтение таймеров реального времени из pstor при первом апдейте
function r_timers_first_load()
	r_timers = {}
	if not oNearest then oNearest = game.get_game_time() end --/ preset
	local name, delay, params
	for a=1,99,1 do
		name = load_variable("rt"..a,nil)
		-- dbglog("timers:> load real pstor> find idx=["..a.."]")
		if name ~= nil then
			-- dbglog("timers:> load real pstor> found idx=["..a.."]")
			params = load_variable("rt"..a.."p",{})
			-- dbglog("timers:> load real pstor> load params=["..tostring(params).."]")
			local val = load_variable("rt"..a.."d",{})
			-- dbglog("timers:> load real pstor> load time=["..tostring(val).."], type=["..type(val).."]")
			if type(val) == 'number' then --/ 'milliseconds', converting to 'ctime'
				delay = set_seconds2ctime(val/1000)
				save_variable("rt"..a.."d", CTimeToTable(delay))
			elseif type(val) == 'table' then
				delay = TableToCTime(val)
			else
				delay = nil
				save_variable("rt"..a, nil)
				save_variable("rt"..a.."d", delay)
				save_variable("rt"..a.."p", delay)
			end
			if delay ~= nil then
				r_timers[a] = {name = name, ctime = delay, params = params}
				if oNearest > delay then
					oNearest = game.CTime(delay) --/ change nearest time
				end

				-- dbglog("timers:> load real> idx=["..a.."], name=["..name.."], action=["..params.."]")
				-- dbglog("timers:> load time=["..Get_StringOnTimeOrDate("D", delay).." "..Get_StringOnTimeOrDate("s", delay).."], nearest time=["..Get_StringOnTimeOrDate("D", oNearest).." "..Get_StringOnTimeOrDate("s", oNearest).."]")
			end
		end
	end
end

-- Чтение таймеров игрового времени из pstor при первом апдейте
function g_timers_first_load()
	g_timers = {}
	if not oNearest then oNearest = game.get_game_time() end --/ preset
	local name, delay, params
	for a=1,99,1 do
		name = load_variable("gt"..a,nil)
		-- dbglog("timers:> load game pstor> find idx=["..a.."]")
		if name ~= nil then
			-- dbglog("timers:> load game pstor> found idx=["..a.."]")
			params = load_variable("gt"..a.."p",{})
			-- dbglog("timers:> load game pstor> load params=["..tostring(params).."]")
			local val = load_variable("gt"..a.."d",{})
			-- dbglog("timers:> load game pstor> load time=["..tostring(val).."], type=["..type(val).."]")
			if type(val) == 'number' then --/ 'minutes', converting to 'ctime'
				delay = set_seconds2ctime(val*60)
				save_variable("gt"..a.."d", CTimeToTable(delay))
			elseif type(val) == 'table' then
				delay = TableToCTime(val)
			else
				delay = nil
				save_variable("gt"..a, nil)
				save_variable("gt"..a.."d", delay)
				save_variable("gt"..a.."p", delay)
			end
			if delay ~= nil then
				g_timers[a] = {name = name, ctime = delay, params = params}
				if oNearest > delay then
					oNearest = game.CTime(delay) --/ change nearest time
				end

				-- dbglog("timers:> load game> idx=["..a.."], name=["..name.."], action=["..params.."]")
				-- dbglog("timers:> load time=["..Get_StringOnTimeOrDate("D", delay).." "..Get_StringOnTimeOrDate("s", delay).."], nearest time=["..Get_StringOnTimeOrDate("D", oNearest).." "..Get_StringOnTimeOrDate("s", oNearest).."]")
			end
		end
	end
end

function CTimeToTable(input)
	if type(input) ~= 'userdata' or type(input.setHMSms) ~= 'function' then return nil end
	local Y,M,D,h,m,s,ms = input:get(0,0,0,0,0,0,0)
	return {Y,M,D,h,m,s,ms}
end

function TableToCTime(input)
	if type(input) ~= 'table' or type(input[7]) ~= 'number' then return nil end
	local oResult = game.CTime()
	oResult:set(input[1], input[2], input[3], input[4], input[5], input[6], input[7])
	return oResult
end

-- Проверка таймеров, использует 3 следующие за ним функции для выбора действия
function check_timers()
	if r_timers == nil then r_timers_first_load() end
	if g_timers == nil then g_timers_first_load() end

	local oTimeCur = game.get_game_time() --/ текущее значение (game-mseconds)
	if oTimeCur >= oNearest then --/ есть просроченный таймер?
		-- dbglog("timers:> check time=["..Get_StringOnTimeOrDate("D", oTimeCur).." "..Get_StringOnTimeOrDate("s", oTimeCur).."], nearest time=["..Get_StringOnTimeOrDate("D", oNearest).." "..Get_StringOnTimeOrDate("s", oNearest).."]")

		oNearest = Set_Rest_GameSeconds(15*60) --/< минимальный период перепроверки ~15мин
		--/ проверка отработавших таймеров и (пере)выбор ближайшего к срабатыванию
		local triggered = false
		for idx,t in pairs(r_timers) do
			if t.ctime then
				if not triggered and t.ctime <= oTimeCur then --/ просрочен?
					-- dbglog("timers:> triggered real time=["..Get_StringOnTimeOrDate("D", t.ctime).." "..Get_StringOnTimeOrDate("s", t.ctime).."]")
					triggered = true --/ запрещаем срабатывание более одного таймера за один update цикл
					__r_timer_found(idx, t.name, t.params) --/> запуск (сработал таймер)
				elseif t.ctime < oNearest then --/ вычисляем 'следующий ближайший'
					-- dbglog("timers:> postponed real time=["..Get_StringOnTimeOrDate("D", t.ctime).." "..Get_StringOnTimeOrDate("s", t.ctime).."]")
					oNearest = game.CTime(t.ctime)
				end
			end
		end
		for idx,t in pairs(g_timers) do
			if t.ctime then
				if not triggered and t.ctime <= oTimeCur then --/ просрочен?
					-- dbglog("timers:> triggered game time=["..Get_StringOnTimeOrDate("D", t.ctime).." "..Get_StringOnTimeOrDate("s", t.ctime).."]")
					triggered = true --/ запрещаем срабатывание более одного таймера за один update цикл
					__g_timer_found(idx, t.name, t.params) --/> запуск (сработал таймер)
				elseif t.ctime < oNearest then --/ вычисляем 'следующий ближайший'
					-- dbglog("timers:> postponed game time=["..Get_StringOnTimeOrDate("D", t.ctime).." "..Get_StringOnTimeOrDate("s", t.ctime).."]")
					oNearest = game.CTime(t.ctime)
				end
			end
		end
	end
end

function __r_timer_found(idx, name, params)
	-- dbglog("timers:> found real> idx=["..idx.."], name=["..name.."], action=["..params.."]")
	r_timers[idx] = nil
	del_variable("rt"..idx)
	del_variable("rt"..idx.."d")
	del_variable("rt"..idx.."p")
	-- dbglog("timers:> action real> idx=["..idx.."], name=["..name.."], action=["..params.."]")
	__do_timer_action(name, params)
end

function __g_timer_found(idx, name, params)
	-- dbglog("timers:> found game> idx=["..idx.."], name=["..name.."], action=["..params.."]")
	g_timers[idx] = nil
	del_variable("gt"..idx)
	del_variable("gt"..idx.."d")
	del_variable("gt"..idx.."p")
	__do_timer_action(name, params)
	-- dbglog("timers:> action game> idx=["..idx.."], name=["..name.."], action=["..params.."]")
end

local timers = nil
function __do_timer_action(timer_name, params)
	if not timers then timers = _G["ogsm_timers"] end
	local timer_action = timers and timers[timer_name]
	if type(timer_action) == 'function' then
		timer_action(timer_name, params)
		return
	end

	if timer_name=="spw" then
		spawn_item_in_inv(params)
		return
	end

	if timer_name=="kill" then
		local obj = level.object_by_id(params)
		if obj and obj:alive() then
			obj:kill(obj)
		else
			switch_online(params)
			start_timer("kill", 0.1, params)
		end
		return
	end

	if timer_name=="bar" then
		db.actor:eat(db.actor:object(params))
		return
	end

	if timer_name=="sav" then
		autosave(params)
		return
	end

	if timer_name=="pss" then
		gi("esc_puzo_squad_spawn")
		return
	end
end

-- удаляем объект из игры
function remove_item(remove_item)
  if remove_item~=nil then
	alife():release(alife():object(remove_item:id()), true)
    return true
  end
  return false
end

-- Спавним объект в инвентарь
function spawn_item_in_inv(spawn_item, npc, p)
	if npc == nil then npc = db.actor end
	if p == nil then p = 1 end
	if math.random(0,1) <= p then
		return alife():create(spawn_item, npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
	end
end

-- Спавним объекты в инвентарь ГГ
function spawn_items_in_inv(spawn_item, num)
	if num == nil or num < 1 then num = 1 end
	for a=1,num,1 do
		local npc = db.actor
		alife():create(spawn_item, npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id())
	end
end

-- Спавним патроны в инвентарь
function spawn_ammo_in_inv(spawn_item,number,npc)
	if npc==nil then
		npc=db.actor
	end
	if number > 0 then
		return se_respawn.create_ammo(spawn_item, npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id(), number)
	end
end


-- Узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
	local rel = obj:relation(target)
	local relation
	if rel==game_object.neutral then
		relation="neutral"
	elseif rel==game_object.friend then
		relation="friend"
	elseif rel==game_object.enemy then
		relation="enemy"
	else
		return false
	end
	return relation
end


-- Колбэк на взятие артефакта
function on_artefact_take(obj)
	local s_obj = alife():object(obj:id())
	if s_obj then
		local pk = get_netpk(s_obj, 1)
		if pk:isOk() then
			local data = pk:get()
			local tbl = data.custom_data:getTable()
			if not tbl.artefact_found then
				xr_statistic.inc_founded_arts_counter()
				tbl.artefact_found = {}
				data.custom_data:setTable(tbl)
				pk:set(data)
			end
		end
	end
end

-- Колбэк на взятие предмета
function on_item_take(obj)
	local cls = obj:clsid()

	if chinese_ammo and cls == clsid.wpn_ammo then chinese_ammo.on_take(obj) end
	if xr_medic then xr_medic.pickup(obj) end

	if ogsm_notepad then ogsm_notepad.OnItemTake(obj:section()) end

	-- фикс замены визуала надетой брони на дефолтный (Artos, *Shoker*)
	if cls == clsid.equ_stalker_s or cls == clsid.equ_military then
		if level.main_input_receiver() then
			need_delayed_otf_fix = true
		else
			outfit_fix_main(obj)
		end
	-- Выдача отдельных инфопоршней для выдачи статей для оптики, глушителей, граников и их выстрелов, а так же ПДА (использованы наработки из OGSM_v2.4.3_Gold_Edition. DEXXX) (monk)
	elseif cls == clsid.wpn_scope_s or cls == clsid.wpn_addon_scope_susat or cls == clsid.wpn_silencer or cls == clsid.wpn_grenade_launcher or cls == clsid.wpn_ammo_og7b or cls == clsid.wpn_ammo_vog25 or cls == clsid.device_pda then
		local sect = obj:section()
		if not has_alife_info(sect .. "_info") then
			db.actor:give_info_portion(sect .. "_info")
		end
	end
end


-- Колбэк на использование предмета из инвентаря ГГ
function on_use_object(section, id)
	-- рюкзак для тайника
	if section == "inv_ruck" then
		local stash = alife():create("active_ruck", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
		level.map_add_object_spot_ser(stash.id, "my_treasure", game.translate_string("ui_st_backpack_my_stash"))
		--news_manager.send_tip(db.actor, game.translate_string("ui_st_backpack_stash_laid"), nil, nil, 5000)
		local news_caption = game.translate_string("st_tip")..". "..game.translate_string("st_actor_name")..":"
		local news_text = "%c[0,0,255,25]"..game.translate_string("ui_st_backpack_stash_laid")
		db.actor:give_game_news(news_caption, news_text, "ui_npc_u_actor", 0, 10000)
		xr_sound.set_sound_play(db.actor:id(), "pda_tips")
		return
	end

	-- экспериментальный КПК
	if string.find(section, "notepad") then
		spawn_item_in_inv("notepad")
		level.start_stop_menu(ogsm_notepad.GetNotepad(get_hud()), true)
		return
	end

	-- прочие предметы, добавляемые во внешних модулях
	local usable_items = _G["ogsm_usable_items"] or {}
	for k,v in ipairs(usable_items) do
		if string.find(section, v[1]) then
			start_timer(v[2], 0.1, {section = section, id = id})
			break
		end
	end
end


-- Колбэк на апдейт ГГ
function on_actor_update(obj)

	-- Fade-эффект при загрузке
	if ogsm_options.show_pause and after_load then
		level.add_pp_effector("stc_fade_out.ppe", 7000, false)
		after_load = false
	end

	-- Обновление таймеров
	check_timers()

	-- Проверка уровня пси-здоровья
	if db.actor.psy_health == 0 then
		db.actor:kill(db.actor)
	end

	-- Вывод координат
	hud_stats()

	-- Проверка, принята ли водка или йадулин
	if ogsm_items then
		ogsm_items.check_drunk()
		ogsm_items.check_hlth()
	end

	-- Обновление постпроцессов
	if ogsm_postprocess then ogsm_postprocess.update() end

	-- Обновление визуального эффекта высокого кровотечения
	if ogsm_hud_effects and ogsm_options.hud_effects then ogsm_hud_effects.update() end

	-- Отображение времени
	if ogsm_clock and ogsm_options.show_clock then ogsm_clock.show_time() end

	-- Обновление шкалы пси-здоровья
	if ogsm_psybar and ogsm_options.show_psybar then ogsm_psybar.show_psybar() end

	-- Обновление индикаторов опасности
	if ogsm_indicators and ogsm_options.show_indicators then ogsm_indicators.show_indicators() end

	-- Обновление индикаторов состояния
	if ogsm_condition and ogsm_options.show_condition then ogsm_condition.show_condition() end

	-- Проверка близости аномалии
	if ogsm_anomaly then ogsm_anomaly.on_update() end

	-- Обновление перепаковщика патронов
	if chinese_ammo and not obj:is_talking() then chinese_ammo.on_update() end

	-- Выдача информации о локации
	local level_name = level.name()
	if not xr_conditions.black_screen() and load_variable("lvl", "marsh") ~= level_name then
		if not has_alife_info(load_variable("lvl", "marsh").."_visited") then
			db.actor:give_info_portion(load_variable("lvl", "marsh").."_visited")
		end
		-- Автосохранение при первом посещении уровня
		if not has_alife_info(level_name.."_visited") then
			start_autosave(level_name)
		end
		save_variable("lvl", level_name)
	end

	-- Фикс замены визуала надетой брони на дефолтный (Artos, *Shoker*)
	if need_delayed_otf_fix and not level.main_input_receiver() then
		outfit_fix_main(db.actor)
		need_delayed_otf_fix = false
	end

	-- Удаляем запоротый объект
	if can_release and ogsm_options.object_to_release ~= nil then
		local obj = alife():object(ogsm_options.object_to_release)
		if obj ~= nil then
			dbglog("releasing corrupt object "..obj:name())
			if obj.squad_id == nil then
				fixme.destroy_object(obj)
			else
				sim_board.get_sim_board().squads[obj.squad_id]:remove_npc(obj.id)
			end
		end
		can_release = false
	end

	-- Kirgudu
	if ogsm_options.surge_type == 2 and xr_surge_hide.periodical_surge_started ~= true then
		-- первичный старт таймера периодического выброса в некоторых случаях его отсутствия
		local surge_timer_exists = load_variable("sts", false)
		if surge_timer_exists ~= true then
			surge_timer_exists = is_g_timer_exists("bl1")
			if surge_timer_exists ~= true and not xr_surge_hide.start_surge and not xr_surge_hide.surge_activated then
				g_start_timer("bl1", 0, ogsm_options.surge_period + math.random(-4,4), 0)
			end
			save_variable("sts", true)
		end
		xr_surge_hide.periodical_surge_started = true
	end
	-- Kirgudu
end

-- Загружаем все переменные, которые нужно, вызывается при загрузке игры автоматически
function on_load()
	-- Первый запуск мода
	if load_variable("frn",true) then
		local sobj = alife():object("val_comendant_dead")
		if sobj then alife():release(sobj) end
		local sobj = alife():story_object(441)
		if sobj then sobj.sim_forced_online = true end
		local sobj = alife():story_object(408)
		if sobj then sobj.sim_forced_online = true end
		if ogsm_sleep then g_start_timer("slp",0,0,6) end
		if ogsm_satiety then g_start_timer("eat",0,0,6) end
		if ogsm_respawn then
			g_start_timer("rsp",0, 5+math.random(-1,1), 0)
			ogsm_respawn.startup_spawn()
		end
		-- Kirgudu
		-- первичный старт таймера периодического выброса в начале новой игры
		if ogsm_options.surge_type == 2 then
			local surge_timer_exists = is_g_timer_exists("bl1")
			if (not surge_timer_exists or surge_timer_exists ~= true) and not xr_surge_hide.start_surge and not xr_surge_hide.surge_activated then
				g_start_timer("bl1", 0, ogsm_options.surge_period + math.random(-4,4), 0)
			end
			save_variable("sts", true)
			xr_surge_hide.periodical_surge_started = true
		end
		-- Kirgudu
		if ogsm_freeplay then ogsm_freeplay.startup_spawn() end
		if ogsm_locations then ogsm_locations.startup_spawn() end
		if ogsm_bring_items then ogsm_bring_items.startup_spawn() end
		if ogsm_rare_items_manager then ogsm_rare_items_manager.get_rim():rnd_all() end
		if ogsm_options.mark_smarts then mark_smarts() end
		if ogsm_options.spawn_military_btr then spawn_military_btr() end
		if ogsm_notepad then ogsm_notepad.OnFirstRun() end
		spawn_item_in_inv("matras")
		save_variable("frn",false)
		save_variable("lvl", level.name())
	end

	-- Проверяем сонность
	if ogsm_sleep then ogsm_sleep.test_sleep_pp() end

	-- Получаем список всех монстров
	if ogsm_respawn then ogsm_respawn.get_level_mobs() end

	-- Получаем список аномалий
	if ogsm_anomaly then ogsm_anomaly.on_load() end

	-- Уборщик брошенного оружия и трупов мутантов
	if ogsm_cleaner then ogsm_cleaner.clean() end

	-- Меняем погоду на ЧАЭС во фриплее
	if level.name() == "stancia_2" and has_alife_info("freeplay") then
		level.set_weather("default_cloudy", true)
	end

	-- Выдаем первую заметку об экологах
	if not has_alife_info("ecolog_info") and db.actor ~= nil then
		db.actor:give_info_portion("ecolog_info")
	end

	-- Менеджер заданий
	if ogsm_rt_manager then
		ogsm_rt_manager.get_rt_manager():on_load()
	end

	-- Инициализируем менеджер экспериментального КПК
	-- printf("Notepad:: 0")
	if ogsm_notepad then ogsm_notepad.GetNotepad(get_hud()) end

	-- Выдача необходимых инфопоршенов при читерском телепорте
	if dbgset and need_jump and load_variable("lvl", "marsh") ~= level.name() and not has_alife_info(load_variable("lvl", "marsh").."_visited") then
		local f = _G["lvl_"..level.name().."_start"]
		if f ~= nil then f.main() end
	end
end

-- Спавним БТР'ы на Кордоне
function on_net_spawn(obj)
	build_btrs_table(obj)
end

btrs_friends={}

function build_btrs_table(obj)
	if obj and (IsStalker(obj) and obj:character_community()=="army" and obj:alive()) or obj:section()=="vehicle_btr" then
			btrs_friends[obj:id()] = obj:section()
	end
end

function spawn_military_btr()
	ogsm_packet.spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-168.11, -29.71, -298.21),80887,629 ) ,"vehicle_btr")
	ogsm_packet.spawn_military_tech_pack( alife():create("vehicle_btr",vector():set(-237.85, -26.23, -378.81),22230,582 ) ,"vehicle_btr")
	ogsm_packet.spawn_military_tech_pack( alife():create("helicopter",vector():set(-150.0, 0.0, -620.0),102570,565 ) ,"helicopter")
end

function on_start_game() --/ from '_g.start_game_callback'
	math.randomseed(device():time_global())
	Initialize_Module('ogsm_notepad', 'init')
	Initialize_Module('ogsm_satiety', 'init')
	Initialize_Module('ogsm_sleep', 'init')
	Initialize_Module('ogsm_items', 'init')
	Initialize_Module('ogsm_marauder', 'init')
	Initialize_Module('ogsm_respawn', 'init')
	Initialize_Module('ogsm_rare_items_manager', 'init')
end

function Initialize_Module(fname, action)
	prefetch(fname) --/ подключение модуля (скрипт-файла)
	local res = fs:exist("$game_scripts$", (fname or "<x>")..".script")
	local module = res and _G[fname]
	if module then
		ASSERT(type(module) == 'table', "Initialize_Module:='"..tostring(fname).."'~wrong, must be a table")
		if action == 'nil' then return true end --/>
		if type(module[action]) == 'function' then
			module[action]()
			return true --/>
		end
	end
	return false --/>
end

-- Отметка смартов на карте
function mark_smarts()
	local sim, obj = alife(), nil
	local name, obj_name, s = "", "", ""
	for i = 1, 65534 do
		obj = sim:object(i)
		if obj and obj:clsid() == clsid.smart_terrain then
			obj_name = obj:name()
			if obj_name ~= "gar_smart_terrain_4_3" and
			   obj_name ~= "agr_smart_terrain_5_7u" then
				name = game.translate_string("st_name_"..obj_name)
				if obj.sim_type then
					if obj.sim_type == "territory" then s = " - Ключевая точка"
					elseif obj.sim_type == "base" then s = " - База группировки"
					elseif obj.sim_type == "resource" then s = " - Ресурсная точка"
					else s = "" end
					name = name..s
				end
				if dbgset then name = name.." - "..obj_name end
				level.map_add_object_spot_ser(obj.id, "smart_name", name)
			end
		end
	end
end


-- Разрешение на удаление квестовых трупов
function allow_release(section)
	local ltx = system_ini()
	if ltx:line_exist(section,"allow_release") then
		local value = ltx:r_bool(section,"allow_release")
		return value
	else
		return true
	end
end


-- Вывод отладочной информации
function dbglog(fmt,...)
	if dbgset then
		local msg = string.format(fmt, ...)
		local msg_no_ws = string.gsub(msg, "%s", "_")
		get_console():execute("load ~:" .. msg_no_ws)
		get_console():execute("flush")
	end
end


-- Строковые функции
function parse_custom_data(str)
 local t={}
 if str then
  for section, section_data in string.gfind(str,"%s*%[([^%]]*)%]%s*([^%[%z]*)%s*") do
   section = trim(section)
   t[section]={}
   for line in string.gfind(trim(section_data), "([^\n]*)\n*") do
    if string.find(line,"=")~=nil then
     for k, v in string.gfind(line, "([^=]-)%s*=%s*(.*)") do
      k = trim(k)
      if k~=nil and k~='' and v~=nil then
       t[section][k]=trim(v)
      end
     end
    else
     for k, v in string.gfind(line, "(.*)") do
      k = trim(k)
      if k~=nil and k~='' then
       t[section][k]="<<no_value>>"
      end
     end
    end
   end
  end
 end
 return t
end
function gen_custom_data(tbl)
 local str=''
 for key, value in pairs(tbl) do
  str = str.."["..key.."]\n"
  for k, v in pairs(value) do
   if v~="<<no_value>>" then
    str=str..k.." = "..v.."\n"
   else
    str=str..k.."\n"
   end
  end
 end
 return str
end
function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end
function trim(s)
	return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
end
function str_explode(div,str,pos1,pos2,clear)
	local t={}
	local cpt, pos

	if pos1 == nil then pos1 = 1 end
	if pos2 == nil then pos2 = pos1 end

	pos1 = tonumber(pos1)
	pos2 = tonumber(pos2)

	local cpt1 = string.find (str, div, pos1, true)
	local cpt2 = string.find (str, div, pos2, true)

	if cpt1 and cpt2 then

		if cpt2-cpt1 > 5 then
			cpt = cpt1
			pos = pos1
		else
			cpt = cpt2
			pos = pos2
		end

		repeat
			if clear then
				table.insert( t, trim(string.sub(str, 1, cpt-1)) )
			else
				table.insert( t, string.sub(str, 1, cpt-1) )
			end
			str = string.sub( str, cpt+string.len(div) )
			cpt = string.find (str, div, pos, true)
		until cpt==nil
	end
	if clear then
		table.insert(t, trim(str))
	else
		table.insert(t, str)
	end
	return t
end


-- Фикс замены визуала надетой брони на дефолтный (Artos, *Shoker*)
function outfit_fix_main(obj)
	local actor_outfit = db.actor:get_current_outfit()
	if actor_outfit and actor_outfit:id() ~= obj:id() then
		db.actor:transfer_item(actor_outfit, db.actor)
	end
end


-- Автосохранение (запуск)
function start_autosave(save_name)
	start_timer("sav", iAutoSaveTimeout, save_name)
end

-- Автосохранение (выполнение)
function autosave(p)
	if p and db.actor and db.actor:alive() then
		if db.actor:is_talking() or has_alife_info("ui_inventory") or has_alife_info("ui_pda") then
			start_timer("sav", iAutoSaveTimeout, p)
			return
		end
		local save_name = user_name().." - "..game.translate_string(p)
		get_console():execute("save "..save_name)
	end
end


-- Developer Mode Cheat Functions --

local iTimefactorStep, iTimefactor = 1000, 0

function acc_time()
	iTimefactor = iTimefactor + iTimefactorStep
	level.set_time_factor(iTimefactor)
	news_manager.send_tip(db.actor, "%c[25,240,25,25]Таймфактор увеличен до "..iTimefactor, nil, "ogsm", 1000)
end

function ret_time()
	local factor = system_ini():r_float("alife", "time_factor")
	level.set_time_factor(factor)
	iTimefactor = 0
	news_manager.send_tip(db.actor, "%c[0,0,255,25]Таймфактор стандартный", nil, "ogsm", 1000)
end

function dec_time()
	iTimefactor = iTimefactor - iTimefactorStep
	local factor = system_ini():r_float("alife", "time_factor")
	if iTimefactor < factor then
		ret_time()
	else
		level.set_time_factor(iTimefactor)
		news_manager.send_tip(db.actor, "%c[255,240,155,25]Таймфактор уменьшен до "..iTimefactor, nil, "ogsm", 1000)
	end
end

function hud_stats()
	local hud = get_hud()
	local lvid, gvid, pos, msg, cs
	if dbgset then
		if db.actor:alive() then
			lvid, gvid, pos = db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:position()
			msg = string.format("lvid: %d, gvid: %d\\n", lvid, gvid) ..	string.format("pos: x=%f, y=%f, z=%f\\n", pos.x, pos.y, pos.z)
			cs = hud:GetCustomStatic("cs_debug")

			if cs == nil then
				hud:AddCustomStatic("cs_debug", true)
				cs = hud:GetCustomStatic("cs_debug")
			else
				cs:wnd():SetText(msg)
			end
		else
			if hud:GetCustomStatic("cs_debug") then get_hud():RemoveCustomStatic("cs_debug") end
		end
	end
end

function log_coords()
	local lvid, gvid = db.actor:level_vertex_id(), db.actor:game_vertex_id()
	local pos = level.vertex_position(lvid)
	local dir = db.actor:direction()
	get_console():execute(string.format("pos:_vector():set(%.3f,%.3f,%.3f),%d,%d___dir:_vector():set(%.3f,%.3f,%.3f)", pos.x, pos.y, pos.z, lvid, gvid, dir.x, dir.y, dir.z))
	get_console():execute("flush")
end

function cheat_inv_spawn()
	local items = {
		{"conserva", 5},
		{"svoboda_exo_outfit", 1},
		{"wpn_groza", 1},
		{"wpn_addon_scope", 1},
		{"detector_elite", 1},
		{"wpn_spas12", 1},
		{"wpn_fn57", 1},
		{"wpn_rpg7", 1},
		{"wpn_svd", 1},
		{"ammo_7.62x54_ap", 21},
		{"ammo_og-7b", 30},
		{"ammo_9x39_ap", 20},
		{"ammo_vog-25p", 31},
		{"ammo_12x70_buck", 20},
		{"ammo_5.7x28_fmj", 10},
		{"grenade_f1", 5},
		{"medkit_scientic", 30},
		{"af_fire", 1},
		{"af_glass", 1},
		{"af_cristall_flower", 2},
		{"af_gold_fish", 2}
	}
	for k,v in pairs(items) do
		spawn_items_in_inv(v[1], v[2])
	end
	db.actor:give_money(20000000)
end

function cheat_obj_params()
	local npc = {
		{name ="red_bridge_stalker_leshiy26168", section = "visual", value = "actors\\stalker_merc\\stalker_merc_1_face_1"},
		{name = "mar_csky_tech", section = "sid", value ="315"}
	}
	for k,v in pairs(npc) do
		local obj = ogsm_packet.change_stalker(v["name"], v["section"], v["value"])
	end
end

function cheat_lc_spawn()
	local level_changers = {
		{
		  sid = 6004,
		  from_level = "from_marsh_1",
		  dest_level = "dest_limansk_1",
		  spot = "level_changer_left_up",
		  hint = "st_lchanger_to_limansk",
		  dir = vector():set(0,0,0),
		  mode = 0,
		  custom = "",
		  show = true
		},
		{
		  sid = 6005,
		  from_level = "from_marsh_2",
		  dest_level = "dest_darkvalley_1",
		  spot = "level_changer_left_up",
		  hint = "st_lchanger_to_darkvalley",
		  dir = vector():set(0,0,0),
		  mode = 0,
		  custom = "",
		  show = true
		}
	}
	for k,v in pairs(level_changers) do
		ogsm_packet.spawn_lc(v)
	end
end


---------------------------- Библиотека служебных скриптов ----------------------------
------------------------- Copyright 2007-2011 DEXXX, xStream --------------------------