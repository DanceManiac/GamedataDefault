----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- Обычное поведение

class "action_process_death"

function action_process_death:__init(obj, storage)
	self.object = obj
	self.st = storage
end

-- Kirgudu
-- НПС, убийство которых героем не должно пройти без последствий
local important_npcs = {
	-- боец ЧН на вышке (Болота) во время первого задания
	{obj_name = "^mar_csky_tutorial_man", info = "mar_csky_tutorial_man_dead"},
	-- командир патруля сталкеров (Кордон) на автобусной остановке
	{obj_name = "^esc_st_patrol_lead", info = "esc_stalker_enemy"},
	-- командир военных на Кордоне
	{obj_name = "^esc_zak_stalkerbase", info = "esc_zak_stalkerbase_killed_by_a_hero"}
}
function action_process_death:death_callback(victim, who)
	local victim_id, victim_name = victim:id(), victim:name()
	if who ~= nil then
		-- проверяем, что убийца - главный герой
		local who_id, who_name = who:id(), who:name()
		if who_id == db.actor:id() then
			-- ищем задание на убийство
			local task_desc = ogsm_rt_manager.get_rt_manager():get_kill_stalker_task_desc_by_npc(victim:id())
			-- если задание существует, делаем запись о том, что оно выполнено главным героем
			if task_desc and task_desc ~= nil then
				task_desc.stalker_killer = "Scar"
			end
			-- проверяем, что убитый - важный персонаж
			for _,v in ipairs(important_npcs) do
				if string.find(victim_name, v.obj_name) then
					-- выдаём инфопорцию
					gi(v.info)
				end
			end
		end
		printf("[%s] killed by [%s]", victim_name, who_name)
		db.storage[victim_id].death.killer = who_id
	else
		printf("[%s] killed by [Unknown]", victim_name)
		db.storage[victim_id].death.killer = -1
-- Kirgudu
	end

	if db.actor then
		if self.st.info then
			xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.info)
		end

		if self.st.info2 then
			xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.info2)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	local action = this.action_process_death(npc, storage)
	xr_logic.subscribe_action_for_events(npc, storage, action)
end


function set_death(npc, ini, scheme, section)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
end

function reset_death(npc, scheme, st, section)
	local death_section = utils.cfg_get_string(st.ini, st.section_logic, "on_death", npc, false, "")
--	printf("reset death for [%s]", npc:name())
	if death_section then
--		printf("reset death, section present")
		local tmp = utils.cfg_get_string(st.ini, death_section, "on_info", npc, false, "")
--		printf("tmp [%s]", tostring(tmp))
		if tmp then
			st.death.info = xr_logic.parse_condlist(npc, death_section, "death", tmp)
		end
--		printf("tmp [%s]", tostring(tmp))
		tmp = utils.cfg_get_string(st.ini, death_section, "on_info2", npc, false, "")
		if tmp then
			st.death.info2 = xr_logic.parse_condlist(npc, death_section, "death", tmp)
		end
	end
end